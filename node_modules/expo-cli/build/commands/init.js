"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _fs() {
  const data = _interopRequireDefault(require("fs"));

  _fs = function () {
    return data;
  };

  return data;
}

function _xdl() {
  const data = require("@expo/xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _padEnd() {
  const data = _interopRequireDefault(require("lodash/padEnd"));

  _padEnd = function () {
    return data;
  };

  return data;
}

function _npmPackageArg() {
  const data = _interopRequireDefault(require("npm-package-arg"));

  _npmPackageArg = function () {
    return data;
  };

  return data;
}

function _pacote() {
  const data = _interopRequireDefault(require("pacote"));

  _pacote = function () {
    return data;
  };

  return data;
}

function _ora() {
  const data = _interopRequireDefault(require("ora"));

  _ora = function () {
    return data;
  };

  return data;
}

function _trimStart() {
  const data = _interopRequireDefault(require("lodash/trimStart"));

  _trimStart = function () {
    return data;
  };

  return data;
}

function _wordwrap() {
  const data = _interopRequireDefault(require("wordwrap"));

  _wordwrap = function () {
    return data;
  };

  return data;
}

function PackageManager() {
  const data = _interopRequireWildcard(require("@expo/package-manager"));

  PackageManager = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _getenv() {
  const data = _interopRequireDefault(require("getenv"));

  _getenv = function () {
    return data;
  };

  return data;
}

function _terminalLink() {
  const data = _interopRequireDefault(require("terminal-link"));

  _terminalLink = function () {
    return data;
  };

  return data;
}

function _prompt() {
  const data = _interopRequireDefault(require("../prompt"));

  _prompt = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _CommandError() {
  const data = _interopRequireDefault(require("../CommandError"));

  _CommandError = function () {
    return data;
  };

  return data;
}

function _ProjectUtils() {
  const data = require("./utils/ProjectUtils");

  _ProjectUtils = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const FEATURED_TEMPLATES = ['----- Managed workflow -----', {
  shortName: 'blank',
  name: 'expo-template-blank',
  description: 'a minimal app as clean as an empty canvas'
}, {
  shortName: 'blank (TypeScript)',
  name: 'expo-template-blank-typescript',
  description: 'same as blank but with TypeScript configuration'
}, {
  shortName: 'tabs',
  name: 'expo-template-tabs',
  description: 'several example screens and tabs using react-navigation'
}, '----- Bare workflow -----', {
  shortName: 'minimal',
  name: 'expo-template-bare-minimum',
  description: 'bare and minimal, just the essentials to get you started'
}, {
  shortName: 'minimal (TypeScript)',
  name: 'expo-template-bare-typescript',
  description: 'same as minimal but with TypeScript configuration'
}];
const BARE_WORKFLOW_TEMPLATES = ['expo-template-bare-minimum', 'expo-template-bare-typescript'];
const isMacOS = process.platform === 'darwin';

async function action(projectDir, command) {
  const options = {
    yes: !!command.yes,
    yarn: !!command.yarn,
    npm: !!command.npm,
    template: command.template,
    /// XXX(ville): this is necessary because with Commander.js, when the --name
    // option is not set, `command.name` will point to `Command.prototype.name`.
    name: typeof command.name === 'string' ? command.name : undefined
  };

  if (options.yes) {
    projectDir = '.';

    if (!options.template) {
      options.template = 'blank';
    }
  }

  let parentDir;
  let dirName;

  if (projectDir) {
    let root = _path().default.resolve(projectDir);

    parentDir = _path().default.dirname(root);
    dirName = _path().default.basename(root);
    let validationResult = validateName(parentDir, dirName);

    if (validationResult !== true) {
      throw new (_CommandError().default)('INVALID_PROJECT_DIR', validationResult);
    }
  } else if (command.parent && command.parent.nonInteractive) {
    throw new (_CommandError().default)('NON_INTERACTIVE', 'The project dir argument is required in non-interactive mode.');
  } else {
    parentDir = process.cwd();
  }

  let templateSpec;

  if (options.template) {
    templateSpec = (0, _npmPackageArg().default)(options.template); // For backwards compatibility, 'blank' and 'tabs' are aliases for
    // 'expo-template-blank' and 'expo-template-tabs', respectively.

    if ((templateSpec.name === 'blank' || templateSpec.name === 'tabs' || templateSpec.name === 'bare-minimum') && templateSpec.registry) {
      templateSpec.escapedName = `expo-template-${templateSpec.name}`;
      templateSpec.name = templateSpec.escapedName;
      templateSpec.raw = templateSpec.escapedName;
    }
  } else {
    const descriptionColumn = Math.max(...FEATURED_TEMPLATES.map(t => typeof t === 'object' ? t.shortName.length : 0)) + 2;
    const {
      template
    } = await (0, _prompt().default)({
      type: 'list',
      name: 'template',
      message: 'Choose a template:',
      pageSize: 20,
      choices: FEATURED_TEMPLATES.map(template => {
        if (typeof template === 'string') {
          return _prompt().default.separator(template);
        } else {
          return {
            value: template.name,
            name: _chalk().default.bold((0, _padEnd().default)(template.shortName, descriptionColumn)) + (0, _trimStart().default)((0, _wordwrap().default)(descriptionColumn + 2, process.stdout.columns || 80)(template.description)),
            short: template.name
          };
        }
      })
    }, {
      nonInteractiveHelp: '--template: argument is required in non-interactive mode. Valid choices are: "blank", "tabs", "bare-minimum" or any custom template (name of npm package).'
    });
    templateSpec = (0, _npmPackageArg().default)(template);
  }

  let initialConfig;
  let templateManifest = await _pacote().default.manifest(templateSpec);
  let isBare = BARE_WORKFLOW_TEMPLATES.includes(templateManifest.name);

  if (isBare) {
    initialConfig = await promptForBareConfig(parentDir, dirName, options);
  } else {
    initialConfig = await promptForManagedConfig(parentDir, dirName, options);
  }

  let packageManager = 'npm';

  if (options.yarn) {
    packageManager = 'yarn';
  } else if (options.npm) {
    packageManager = 'npm';
  } else if (PackageManager().shouldUseYarn()) {
    packageManager = 'yarn';

    _log().default.newLine();

    (0, _log().default)('🧶 Using Yarn to install packages. You can pass --npm to use npm instead.');

    _log().default.newLine();
  } else {
    packageManager = 'npm';

    _log().default.newLine();

    (0, _log().default)('📦 Using npm to install packages. You can pass --yarn to use Yarn instead.');

    _log().default.newLine();
  }

  let extractTemplateStep = logNewSection('Downloading and extracting project files.');
  let projectPath;

  try {
    projectPath = await _xdl().Exp.extractAndPrepareTemplateAppAsync(templateSpec, _path().default.join(parentDir, dirName || ('expo' in initialConfig ? initialConfig.expo.slug : initialConfig.name)), initialConfig);
    extractTemplateStep.succeed('Downloaded and extracted project files.');
  } catch (e) {
    extractTemplateStep.fail('Something went wrong in downloading and extracting the project files.');
    throw e;
  } // for now, we will just init a git repo if they have git installed and the
  // project is not inside an existing git tree, and do it silently. we should
  // at some point check if git is installed and actually bail out if not, because
  // npm install will fail with a confusing error if so.


  try {
    // check if git is installed
    // check if inside git repo
    await _xdl().Exp.initGitRepoAsync(projectPath, {
      silent: true,
      commit: true
    });
  } catch (_unused) {// todo: check if git is installed, bail out
  }

  let installJsDepsStep = logNewSection('Installing JavaScript dependencies.');

  try {
    await _xdl().Exp.installDependenciesAsync(projectPath, packageManager, {
      silent: true
    });
    installJsDepsStep.succeed('Installed JavaScript dependencies.');
  } catch (_unused2) {
    installJsDepsStep.fail(`Something when wrong installing JavaScript dependencies. Check your ${packageManager} logs. Continuing to initialize the app.`);
  }

  let cdPath = _path().default.relative(process.cwd(), projectPath);

  if (cdPath.length > projectPath.length) {
    cdPath = projectPath;
  }

  if (isBare) {
    let podsInstalled = false;

    try {
      podsInstalled = await installPodsAsync(projectPath);
    } catch (_) {}

    _log().default.newLine();

    let showPublishBeforeBuildWarning = await (0, _ProjectUtils().usesOldExpoUpdatesAsync)(projectPath);
    await logProjectReadyAsync({
      cdPath,
      packageManager,
      workflow: 'bare',
      showPublishBeforeBuildWarning
    });

    if (!podsInstalled && process.platform === 'darwin') {
      var _cdPath;

      _log().default.newLine();

      _log().default.nested(`⚠️  Before running your app on iOS, make sure you have CocoaPods installed and initialize the project:`);

      _log().default.nested('');

      _log().default.nested(`  cd ${(_cdPath = cdPath) !== null && _cdPath !== void 0 ? _cdPath : '.'}/ios`);

      _log().default.nested(`  pod install`);

      _log().default.nested('');
    }
  } else {
    _log().default.newLine();

    await logProjectReadyAsync({
      cdPath,
      packageManager,
      workflow: 'managed'
    });
  }
}

function logProjectReadyAsync({
  cdPath,
  packageManager,
  workflow,
  showPublishBeforeBuildWarning
}) {
  _log().default.nested(_chalk().default.bold(`✅ Your project is ready!`));

  _log().default.newLine(); // empty string if project was created in current directory


  if (cdPath) {
    _log().default.nested(`To run your project, navigate to the directory and run one of the following ${packageManager} commands.`);

    _log().default.newLine();

    _log().default.nested(`- ${_chalk().default.bold('cd ' + cdPath)}`);
  } else {
    _log().default.nested(`To run your project, run one of the following ${packageManager} commands.`);

    _log().default.newLine();
  }

  if (workflow === 'managed') {
    _log().default.nested(`- ${_chalk().default.bold(`${packageManager} start`)} # you can open iOS, Android, or web from here, or run them directly with the commands below.`);
  }

  _log().default.nested(`- ${_chalk().default.bold(packageManager === 'npm' ? 'npm run android' : 'yarn android')}`);

  let macOSComment = '';

  if (!isMacOS && workflow === 'bare') {
    macOSComment = ' # you need to use macOS to build the iOS project - use managed workflow if you need to do iOS development without a Mac';
  } else if (!isMacOS && workflow === 'managed') {
    macOSComment = ' # requires an iOS device or macOS for access to an iOS simulator';
  }

  _log().default.nested(`- ${_chalk().default.bold(packageManager === 'npm' ? 'npm run ios' : 'yarn ios')}${macOSComment}`);

  _log().default.nested(`- ${_chalk().default.bold(packageManager === 'npm' ? 'npm run web' : 'yarn web')}`);

  if (workflow === 'bare') {
    _log().default.newLine();

    _log().default.nested(`💡 You can also open up the projects in the ${_chalk().default.bold('ios')} and ${_chalk().default.bold('android')} directories with their respective IDEs.`);

    if (showPublishBeforeBuildWarning) {
      _log().default.nested(`- 🚀 ${(0, _terminalLink().default)('expo-updates', 'https://github.com/expo/expo/blob/master/packages/expo-updates/README.md')} has been configured in your project. Before you do a release build, make sure you run ${_chalk().default.bold('expo publish')}. ${(0, _terminalLink().default)('Learn more.', 'https://expo.fyi/release-builds-with-expo-updates')}`);
    } // TODO: add equivalent of this or some command to wrap it:
    // # ios
    // $ open -a Xcode ./ios/{PROJECT_NAME}.xcworkspace
    // # android
    // $ open -a /Applications/Android\\ Studio.app ./android

  }
}

async function installPodsAsync(projectRoot) {
  let step = logNewSection('Installing CocoaPods.');

  if (process.platform !== 'darwin') {
    step.succeed('Skipped installing CocoaPods because operating system is not on macOS.');
    return false;
  }

  const packageManager = new (PackageManager().CocoaPodsPackageManager)({
    cwd: _path().default.join(projectRoot, 'ios'),
    log: _log().default,
    silent: _getenv().default.boolish('EXPO_DEBUG', true)
  });

  if (!(await packageManager.isCLIInstalledAsync())) {
    try {
      step.text = 'CocoaPods CLI not found in your PATH, installing it now.';
      step.render();
      await packageManager.installCLIAsync();
      step.succeed('Installed CocoaPods CLI');
      step = logNewSection('Running `pod install` in the `ios` directory.');
    } catch (e) {
      step.stopAndPersist({
        symbol: '⚠️ ',
        text: _chalk().default.red('Unable to install the CocoaPods CLI. Continuing with initializing the project, you can install CocoaPods afterwards.')
      });

      if (e.message) {
        (0, _log().default)(`- ${e.message}`);
      }

      return false;
    }
  }

  try {
    await packageManager.installAsync();
    step.succeed('Installed pods and initialized Xcode workspace.');
    return true;
  } catch (e) {
    step.stopAndPersist({
      symbol: '⚠️ ',
      text: _chalk().default.red('Something when wrong running `pod install` in the `ios` directory. Continuing with initializing the project, you can debug this afterwards.')
    });

    if (e.message) {
      (0, _log().default)(`- ${e.message}`);
    }

    return false;
  }
}

function logNewSection(title) {
  let spinner = (0, _ora().default)(_chalk().default.bold(title));
  spinner.start();
  return spinner;
}

function validateName(parentDir, name) {
  if (typeof name !== 'string' || name === '') {
    return 'The project name can not be empty.';
  }

  if (!/^[a-z0-9@.\-_]+$/i.test(name)) {
    return 'The project name can only contain URL-friendly characters.';
  }

  let dir = _path().default.join(parentDir, name);

  if (!isNonExistentOrEmptyDir(dir)) {
    return `The path "${dir}" already exists. Please choose a different parent directory or project name.`;
  }

  return true;
}

function validateProjectName(name) {
  return /^[a-z0-9]+$/i.test(name) || 'Project name can only include ASCII characters A-Z, a-z and 0-9';
}

function isNonExistentOrEmptyDir(dir) {
  try {
    return _fs().default.statSync(dir).isDirectory() && _fs().default.readdirSync(dir).length === 0;
  } catch (error) {
    if (error.code === 'ENOENT') {
      return true;
    }

    throw error;
  }
}

async function promptForBareConfig(parentDir, dirName, options) {
  let projectName;

  if (dirName) {
    let validationResult = validateProjectName(dirName);

    if (validationResult !== true) {
      throw new (_CommandError().default)('INVALID_PROJECT_NAME', validationResult);
    }

    projectName = dirName;
  } else {
    ({
      projectName
    } = await (0, _prompt().default)({
      name: 'projectName',
      message: 'What would you like to name your app?',
      default: 'my-app',
      filter: name => name.trim(),
      validate: name => validateProjectName(name)
    }));
  }

  return {
    name: projectName,
    expo: {
      name: options.name || projectName,
      slug: projectName
    }
  };
}

async function promptForManagedConfig(parentDir, dirName, options) {
  let slug;

  if (dirName) {
    slug = dirName;
  } else {
    ({
      slug
    } = await (0, _prompt().default)({
      name: 'slug',
      message: 'What would you like to name your app?',
      default: 'my-app',
      filter: name => name.trim(),
      validate: name => validateName(parentDir, name)
    }));
  }

  const expo = {
    name: slug,
    slug
  };

  if (options.name) {
    expo.name = options.name;
  }

  return {
    expo
  };
}

function _default(program) {
  program.command('init [project-dir]').alias('i').description('Initializes a directory with an example project. Run it without any options and you will be prompted for the name and type.').option('-t, --template [name]', 'Specify which template to use. Valid options are "blank", "tabs", "bare-minimum" or a package on npm (e.g. "expo-template-bare-typescript") that includes an Expo project template.').option('--npm', 'Use npm to install dependencies. (default when Yarn is not installed)').option('--yarn', 'Use Yarn to install dependencies. (default when Yarn is installed)').option('--name [name]', 'The name of your app visible on the home screen.').option('--yes', 'Use default options. Same as "expo init . --template blank').asyncAction(action);
}
//# sourceMappingURL=init.js.map