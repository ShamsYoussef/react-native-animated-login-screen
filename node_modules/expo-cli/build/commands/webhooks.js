"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _xdl() {
  const data = require("@expo/xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _inquirer() {
  const data = _interopRequireDefault(require("inquirer"));

  _inquirer = function () {
    return data;
  };

  return data;
}

function _validator() {
  const data = _interopRequireDefault(require("validator"));

  _validator = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const WEBHOOK_TYPES = ['build'];

function _default(program) {
  program.command('webhooks:set [project-dir]').option('--url <webhook-url>', 'Webhook to be called after building the app.').option('--event <webhook-type>', 'Type of webhook: [build].').option('--secret <webhook-secret>', 'Secret to be used to calculate the webhook request payload signature (check docs for more details). It has to be at least 16 characters long.').description(`Set a webhook for the project.`).asyncActionProjectDir(async (projectDir, _options) => {
    const options = await _sanitizeOptions(_options);
    const secret = options.secret;
    const webhookData = { ...options,
      secret
    };
    const {
      args: {
        remoteFullPackageName: experienceName
      }
    } = await _xdl().Exp.getPublishInfoAsync(projectDir);
    (0, _log().default)(`Setting ${webhookData.event} webhook and secret for ${experienceName}`);

    try {
      await _xdl().Webhooks.setWebhookAsync(experienceName, webhookData);
    } catch (e) {
      _log().default.error(e);

      throw new Error('Unable to set webhook and secret for this project.');
    }

    (0, _log().default)('All done!');
  });
  program.command('webhooks:show [project-dir]').description(`Show webhooks for the project.`).asyncActionProjectDir(async projectDir => {
    const {
      args: {
        remoteFullPackageName: experienceName
      }
    } = await _xdl().Exp.getPublishInfoAsync(projectDir);
    (0, _log().default)(`Fetching webhooks for ${experienceName}`);

    try {
      const webhooks = await _xdl().Webhooks.getWebhooksAsync(experienceName);

      if (!webhooks || webhooks.length === 0) {
        (0, _log().default)(_chalk().default.bold("You don't have any webhook set for this project."));
      } else {
        for (const webhook of webhooks) {
          const {
            event,
            url,
            secret
          } = webhook;
          (0, _log().default)();
          (0, _log().default)(`Webhook type: ${_chalk().default.bold(event)}`);
          (0, _log().default)(`Webhook URL: ${_chalk().default.bold(url)}`);
          (0, _log().default)(`Webhook secret: ${_chalk().default.bold(secret)}`);
        }
      }
    } catch (e) {
      _log().default.error(e);

      throw new Error('Unable to fetch webhooks for this project.');
    }
  });
  program.command('webhooks:clear [project-dir]').option('--event <webhook-type>', 'Type of webhook: [build].').description(`Clear a webhook associated with this project.`).asyncActionProjectDir(async (projectDir, options) => {
    const event = _sanitizeEvent(options.event);

    const {
      args: {
        remoteFullPackageName: experienceName
      }
    } = await _xdl().Exp.getPublishInfoAsync(projectDir);
    (0, _log().default)(`Clearing webhooks for ${experienceName}`);

    try {
      await _xdl().Webhooks.deleteWebhooksAsync(experienceName, event);
    } catch (e) {
      _log().default.error(e);

      throw new Error('Unable to clear webhook and secret for this project.');
    }

    (0, _log().default)('All done!');
  });
}

async function _sanitizeOptions(options) {
  let {
    url,
    secret,
    event: _event = 'build'
  } = options;

  const event = _sanitizeEvent(_event);

  if (!event) {
    throw new Error('Webhook type has to be provided');
  }

  if (!url) {
    throw new Error('You must provide --url parameter');
  }

  const isValidUrl = _validator().default.isURL(url, {
    protocols: ['http', 'https'],
    require_protocol: true
  });

  if (!isValidUrl) {
    throw new Error('The provided webhook URL is invalid and must be an absolute URL, including a scheme.');
  }

  if (secret) {
    const secretString = String(secret);

    if (secretString.length < 16 || secretString.length > 1000) {
      throw new Error('Webhook secret has be at least 16 and not more than 1000 characters long');
    }
  } else {
    secret = await _askForSecret();
  }

  return {
    url,
    secret,
    event
  };
}

function _sanitizeEvent(event, required = false) {
  if (!event) {
    // we don't have anything to sanitize here, continue
    return event;
  }

  if (!WEBHOOK_TYPES.includes(event)) {
    throw new Error(`Unsupported webhook type: ${event}`);
  }

  return event;
}

async function _askForSecret() {
  const {
    secret
  } = await _inquirer().default.prompt({
    type: 'password',
    name: 'secret',
    message: 'Webhook secret (at least 16 and not more than 1000 characters):'
  });

  if (secret.length < 16 || secret.length > 1000) {
    _log().default.error('Webhook secret has be at least 16 and not more than 1000 characters long');

    return await _askForSecret();
  } else {
    return secret;
  }
}
//# sourceMappingURL=webhooks.js.map