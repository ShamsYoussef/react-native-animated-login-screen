"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _os() {
  const data = _interopRequireDefault(require("os"));

  _os = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _pickBy() {
  const data = _interopRequireDefault(require("lodash/pickBy"));

  _pickBy = function () {
    return data;
  };

  return data;
}

function _xdl() {
  const data = require("@expo/xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _terminalLink() {
  const data = _interopRequireDefault(require("terminal-link"));

  _terminalLink = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _BaseBuilder() {
  const data = _interopRequireDefault(require("../BaseBuilder"));

  _BaseBuilder = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function utils() {
  const data = _interopRequireWildcard(require("../utils"));

  utils = function () {
    return data;
  };

  return data;
}

function apple() {
  const data = _interopRequireWildcard(require("../../../appleApi"));

  apple = function () {
    return data;
  };

  return data;
}

function _prompt() {
  const data = _interopRequireDefault(require("../../../prompt"));

  _prompt = function () {
    return data;
  };

  return data;
}

function _image() {
  const data = require("./utils/image");

  _image = function () {
    return data;
  };

  return data;
}

function _route() {
  const data = require("../../../credentials/route");

  _route = function () {
    return data;
  };

  return data;
}

function _context() {
  const data = require("../../../credentials/context");

  _context = function () {
    return data;
  };

  return data;
}

function _list() {
  const data = require("../../../credentials/actions/list");

  _list = function () {
    return data;
  };

  return data;
}

function _SetupIosDist() {
  const data = require("../../../credentials/views/SetupIosDist");

  _SetupIosDist = function () {
    return data;
  };

  return data;
}

function _SetupIosPush() {
  const data = require("../../../credentials/views/SetupIosPush");

  _SetupIosPush = function () {
    return data;
  };

  return data;
}

function _SetupIosProvisioningProfile() {
  const data = require("../../../credentials/views/SetupIosProvisioningProfile");

  _SetupIosProvisioningProfile = function () {
    return data;
  };

  return data;
}

function _CommandError() {
  const data = _interopRequireWildcard(require("../../../CommandError"));

  _CommandError = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../../../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _IosDistCert() {
  const data = require("../../../credentials/views/IosDistCert");

  _IosDistCert = function () {
    return data;
  };

  return data;
}

function _IosPushCredentials() {
  const data = require("../../../credentials/views/IosPushCredentials");

  _IosPushCredentials = function () {
    return data;
  };

  return data;
}

function _IosProvisioningProfile() {
  const data = require("../../../credentials/views/IosProvisioningProfile");

  _IosProvisioningProfile = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function missingBundleIdentifierError() {
  return new (_xdl().XDLError)('INVALID_OPTIONS', `Your project must have a bundleIdentifier set in app.json.
See https://docs.expo.io/distribution/building-standalone-apps/#2-configure-appjson`);
}

class IOSBuilder extends _BaseBuilder().default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "appleCtx", void 0);
  }

  async run() {
    await this.validateProject();
    this.maybeWarnDamagedSimulator();

    _log().default.addNewLineIfNone();

    await this.checkForBuildInProgress();

    if (this.options.type === 'archive') {
      await this.prepareCredentials();
    }

    const publishedExpIds = await this.ensureProjectIsPublished();

    if (!this.options.publicUrl) {
      await this.checkStatusBeforeBuild();
    }

    await this.build(publishedExpIds);
    this.maybeWarnDamagedSimulator();
  }

  async validateProject() {
    var _this$manifest$ios;

    const bundleIdentifier = (_this$manifest$ios = this.manifest.ios) === null || _this$manifest$ios === void 0 ? void 0 : _this$manifest$ios.bundleIdentifier;
    const sdkVersion = this.manifest.sdkVersion;
    await this.validateIcon();

    if (!bundleIdentifier) {
      throw missingBundleIdentifierError();
    }

    await utils().checkIfSdkIsSupported(sdkVersion, _constants().PLATFORMS.IOS);
  }

  async getAppleCtx() {
    if (!this.appleCtx) {
      await apple().setup();
      this.appleCtx = await apple().authenticate(this.options);
    }

    return this.appleCtx;
  } // Try to get the user to provide Apple credentials upfront
  // We will be able to do full validation of their iOS creds this way


  async bestEffortAppleCtx(ctx) {
    if (ctx.hasAppleCtx()) {
      // skip prompts if already have apple ctx
      return;
    }

    if (this.options.appleId) {
      // skip prompts and auto authenticate if flags are passed
      return await ctx.ensureAppleCtx(this.options);
    }

    const nonInteractive = this.options.parent && this.options.parent.nonInteractive;

    if (nonInteractive) {
      return;
    }

    const {
      confirm
    } = await (0, _prompt().default)([{
      type: 'confirm',
      name: 'confirm',
      message: `Do you have access to the Apple account that will be used for submitting this app to the App Store?`
    }]);

    if (confirm) {
      return await ctx.ensureAppleCtx(this.options);
    } else {
      (0, _log().default)(_chalk().default.green('No problem! ðŸ‘Œ \nWe canâ€™t auto-generate credentials if you donâ€™t have access to the main Apple account. \nBut we can still set it up if you upload your credentials.'));
    }
  }

  async prepareCredentials() {
    var _this$manifest$owner, _this$user, _this$manifest$ios2;

    // TODO: Fix forcing the username to be valid
    const username = (_this$manifest$owner = this.manifest.owner) !== null && _this$manifest$owner !== void 0 ? _this$manifest$owner : (_this$user = this.user) === null || _this$user === void 0 ? void 0 : _this$user.username;
    const experienceName = `@${username}/${this.manifest.slug}`;
    const bundleIdentifier = (_this$manifest$ios2 = this.manifest.ios) === null || _this$manifest$ios2 === void 0 ? void 0 : _this$manifest$ios2.bundleIdentifier;
    if (!bundleIdentifier) throw missingBundleIdentifierError();
    const context = new (_context().Context)();
    await context.init(this.projectDir);
    await this.clearAndRevokeCredentialsIfRequested(context, {
      experienceName,
      bundleIdentifier
    });

    if (this.options.skipCredentialsCheck) {
      (0, _log().default)('Skipping credentials check...');
      return;
    }

    await this.bestEffortAppleCtx(context);

    try {
      await this.produceCredentials(context, experienceName, bundleIdentifier);
    } catch (e) {
      if (e.code === _CommandError().ErrorCodes.NON_INTERACTIVE) {
        _log().default.newLine();

        const link = (0, _terminalLink().default)('expo.fyi/credentials-non-interactive', 'https://expo.fyi/credentials-non-interactive');
        (0, _log().default)(_chalk().default.bold.red(`Additional information needed to setup credentials in non-interactive mode.`));
        (0, _log().default)(_chalk().default.bold.red(`Learn more about how to resolve this: ${link}.`));

        _log().default.newLine(); // We don't want to display project credentials when we bail out due to
        // non-interactive mode error, because we are unable to recover without
        // user input.


        throw new (_CommandError().default)(_CommandError().ErrorCodes.NON_INTERACTIVE, 'Unable to proceed, see the above error message.');
      }

      (0, _log().default)(_chalk().default.bold.red('Failed to prepare all credentials. \nThe next time you build, we will automatically use the following configuration:'));
      throw e;
    } finally {
      const credentials = await context.ios.getAllCredentials();
      (0, _list().displayProjectCredentials)(experienceName, bundleIdentifier, credentials);
    }
  }

  async _setupDistCert(ctx, experienceName, bundleIdentifier, appCredentials) {
    try {
      const nonInteractive = this.options.parent && this.options.parent.nonInteractive;
      const distCertFromParams = await (0, _IosDistCert().getDistCertFromParams)(this.options);

      if (distCertFromParams) {
        await (0, _IosDistCert().useDistCertFromParams)(ctx, appCredentials, distCertFromParams);
      } else {
        await (0, _route().runCredentialsManager)(ctx, new (_SetupIosDist().SetupIosDist)({
          experienceName,
          bundleIdentifier,
          nonInteractive
        }));
      }
    } catch (e) {
      _log().default.error('Failed to set up Distribution Certificate');

      throw e;
    }
  }

  async _setupPushCert(ctx, experienceName, bundleIdentifier, appCredentials) {
    try {
      const nonInteractive = this.options.parent && this.options.parent.nonInteractive;
      const pushKeyFromParams = await (0, _IosPushCredentials().getPushKeyFromParams)(this.options);

      if (pushKeyFromParams) {
        await (0, _IosPushCredentials().usePushKeyFromParams)(ctx, appCredentials, pushKeyFromParams);
      } else {
        await (0, _route().runCredentialsManager)(ctx, new (_SetupIosPush().SetupIosPush)({
          experienceName,
          bundleIdentifier,
          nonInteractive
        }));
      }
    } catch (e) {
      _log().default.error('Failed to set up Push Key');

      throw e;
    }
  }

  async _setupProvisioningProfile(ctx, experienceName, bundleIdentifier, appCredentials, distributionCert) {
    try {
      const nonInteractive = this.options.parent && this.options.parent.nonInteractive;
      const provisioningProfileFromParams = await (0, _IosProvisioningProfile().getProvisioningProfileFromParams)(this.options);

      if (provisioningProfileFromParams) {
        await (0, _IosProvisioningProfile().useProvisioningProfileFromParams)(ctx, appCredentials, this.options.teamId, provisioningProfileFromParams, distributionCert);
      } else {
        await (0, _route().runCredentialsManager)(ctx, new (_SetupIosProvisioningProfile().SetupIosProvisioningProfile)({
          experienceName,
          bundleIdentifier,
          distCert: distributionCert,
          nonInteractive
        }));
      }
    } catch (e) {
      _log().default.error('Failed to set up Provisioning Profile');

      throw e;
    }
  }

  async produceCredentials(ctx, experienceName, bundleIdentifier) {
    const appCredentials = await ctx.ios.getAppCredentials(experienceName, bundleIdentifier);

    if (ctx.hasAppleCtx()) {
      await apple().ensureAppExists(ctx.appleCtx, {
        experienceName,
        bundleIdentifier
      }, {
        enablePushNotifications: true
      });
    }

    await this._setupDistCert(ctx, experienceName, bundleIdentifier, appCredentials);
    const distributionCert = await ctx.ios.getDistCert(experienceName, bundleIdentifier);

    if (!distributionCert) {
      throw new (_CommandError().default)('INSUFFICIENT_CREDENTIALS', `This build request requires a valid distribution certificate.`);
    }

    await this._setupPushCert(ctx, experienceName, bundleIdentifier, appCredentials);
    await this._setupProvisioningProfile(ctx, experienceName, bundleIdentifier, appCredentials, distributionCert);
  }

  async clearAndRevokeCredentialsIfRequested(ctx, projectMetadata) {
    const {
      clearCredentials,
      clearDistCert,
      clearPushKey,
      clearPushCert,
      clearProvisioningProfile
    } = this.options;
    const shouldClearAnything = clearCredentials || clearDistCert || clearPushKey || clearPushCert || clearProvisioningProfile;

    if (shouldClearAnything) {
      const {
        experienceName,
        bundleIdentifier
      } = projectMetadata;
      const credsToClear = this.determineCredentialsToClear();
      await this.clearCredentials(ctx, experienceName, bundleIdentifier, credsToClear);
    }
  }

  async clearCredentials(ctx, experienceName, bundleIdentifier, credsToClear) {
    const shouldRevokeOnApple = this.options.revokeCredentials;
    const nonInteractive = this.options.parent && this.options.parent.nonInteractive;
    const distributionCert = await ctx.ios.getDistCert(experienceName, bundleIdentifier);

    if (credsToClear.distributionCert && distributionCert) {
      await new (_IosDistCert().RemoveIosDist)(shouldRevokeOnApple, nonInteractive).removeSpecific(ctx, distributionCert);
    }

    const pushKey = await ctx.ios.getPushKey(experienceName, bundleIdentifier);

    if (credsToClear.pushKey && pushKey) {
      await new (_IosPushCredentials().RemoveIosPush)(shouldRevokeOnApple, nonInteractive).removeSpecific(ctx, pushKey);
    }

    const appCredentials = await ctx.ios.getAppCredentials(experienceName, bundleIdentifier);
    const provisioningProfile = await ctx.ios.getProvisioningProfile(experienceName, bundleIdentifier);

    if (credsToClear.provisioningProfile && provisioningProfile) {
      await new (_IosProvisioningProfile().RemoveProvisioningProfile)(shouldRevokeOnApple, nonInteractive).removeSpecific(ctx, appCredentials);
    }

    const pushCert = await ctx.ios.getPushCert(experienceName, bundleIdentifier);

    if (credsToClear.pushCert && pushCert) {
      await ctx.ios.deletePushCert(experienceName, bundleIdentifier);
    }
  }

  determineCredentialsToClear() {
    const {
      clearCredentials,
      clearDistCert,
      clearPushKey,
      clearPushCert,
      clearProvisioningProfile
    } = this.options;
    const credsToClearAll = {
      distributionCert: Boolean(clearCredentials || clearDistCert),
      pushKey: Boolean(clearCredentials || clearPushKey),
      // TODO: backward compatibility, remove when all users migrate to push keys
      pushCert: Boolean(clearCredentials || clearPushCert),
      provisioningProfile: Boolean(clearCredentials || clearProvisioningProfile)
    };
    return (0, _pickBy().default)(credsToClearAll);
  }

  async ensureProjectIsPublished() {
    if (this.options.publicUrl) {
      return undefined;
    } else {
      return await this.ensureReleaseExists();
    }
  }

  platform() {
    return _constants().PLATFORMS.IOS;
  } // validates whether the icon doesn't have transparency


  async validateIcon() {
    try {
      var _this$manifest$ios$ic, _this$manifest$ios3;

      const icon = (_this$manifest$ios$ic = (_this$manifest$ios3 = this.manifest.ios) === null || _this$manifest$ios3 === void 0 ? void 0 : _this$manifest$ios3.icon) !== null && _this$manifest$ios$ic !== void 0 ? _this$manifest$ios$ic : this.manifest.icon;

      if (!icon) {
        // icon is optional
        return;
      }

      await (0, _image().ensurePNGIsNotTransparent)(icon);
    } catch (err) {
      if (err instanceof _xdl().XDLError) {
        throw err;
      } else {// something weird happened, let's assume the icon is correct
      }
    }
  } // warns for "damaged" builds when targeting simulator
  // see: https://github.com/expo/expo-cli/issues/1197


  maybeWarnDamagedSimulator() {
    // see: https://en.wikipedia.org/wiki/Darwin_%28operating_system%29#Release_history
    const isMacOsCatalinaOrLater = _os().default.platform() === 'darwin' && _semver().default.satisfies(_os().default.release(), '>=19.0.0');

    if (isMacOsCatalinaOrLater && this.options.type === 'simulator') {
      _log().default.newLine();

      (0, _log().default)(_chalk().default.bold(`ðŸš¨ If the build is not installable on your simulator because of "${_chalk().default.underline(`... is damaged and can't be opened.`)}", please run:`));
      (0, _log().default)(_chalk().default.grey.bold('xattr -rd com.apple.quarantine /path/to/your.app'));
    }
  }

}

var _default = IOSBuilder;
exports.default = _default;
//# sourceMappingURL=IOSBuilder.js.map