"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _xdl() {
  const data = require("@expo/xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _BaseBuilder() {
  const data = _interopRequireDefault(require("./BaseBuilder"));

  _BaseBuilder = function () {
    return data;
  };

  return data;
}

function _IOSBuilder() {
  const data = _interopRequireDefault(require("./ios/IOSBuilder"));

  _IOSBuilder = function () {
    return data;
  };

  return data;
}

function _AndroidBuilder() {
  const data = _interopRequireDefault(require("./AndroidBuilder"));

  _AndroidBuilder = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _CommandError() {
  const data = _interopRequireDefault(require("../../CommandError"));

  _CommandError = function () {
    return data;
  };

  return data;
}

function ProjectUtils() {
  const data = _interopRequireWildcard(require("../utils/ProjectUtils"));

  ProjectUtils = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("./utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _prompt() {
  const data = _interopRequireDefault(require("../../prompt"));

  _prompt = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function maybeBailOnWorkflowWarning({
  projectDir,
  platform,
  nonInteractive
}) {
  const {
    workflow
  } = await ProjectUtils().findProjectRootAsync(projectDir);

  if (workflow === 'managed') {
    return false;
  }

  const command = `expo build:${platform}`;

  _log().default.warn(_chalk().default.bold(`⚠️  ${command} currently only supports managed workflow apps.`));

  _log().default.warn(`If you proceed with this command, we can run the build for you but it will not include any custom native modules or changes that you have made to your local native projects.`);

  _log().default.warn(`Unless you are sure that you know what you are doing, we recommend aborting the build and doing a native release build through ${platform === 'ios' ? 'Xcode' : 'Android Studio'}.`);

  if (nonInteractive) {
    _log().default.warn(`Skipping confirmation prompt because non-interactive mode is enabled.`);

    return false;
  }

  const answer = await (0, _prompt().default)({
    type: 'confirm',
    name: 'ignoreWorkflowWarning',
    message: `Would you like to proceed?`
  });
  return !answer.ignoreWorkflowWarning;
}

function _default(program) {
  program.command('build:ios [project-dir]').alias('bi').option('-c, --clear-credentials', 'Clear all credentials stored on Expo servers.').option('--clear-dist-cert', 'Remove Distribution Certificate stored on Expo servers.').option('--clear-push-key', 'Remove Push Notifications Key stored on Expo servers.').option('--clear-push-cert', 'Remove Push Notifications Certificate stored on Expo servers. Use of Push Notifications Certificates is deprecated.').option('--clear-provisioning-profile', 'Remove Provisioning Profile stored on Expo servers.').option('-r --revoke-credentials', 'Revoke credentials on developer.apple.com, select appropriate using --clear-* options.').option('--apple-id <login>', 'Apple ID username (please also set the Apple ID password as EXPO_APPLE_PASSWORD environment variable).').option('-t --type <build>', 'Type of build: [archive|simulator].').option('--release-channel <channel-name>', 'Pull from specified release channel.', 'default').option('--no-publish', 'Disable automatic publishing before building.').option('--no-wait', 'Exit immediately after scheduling build.').option('--team-id <apple-teamId>', 'Apple Team ID.').option('--dist-p12-path <dist.p12>', 'Path to your Distribution Certificate P12 (set password as EXPO_IOS_DIST_P12_PASSWORD environment variable).').option('--push-id <push-id>', 'Push Key ID (ex: 123AB4C56D).').option('--push-p8-path <push.p8>', 'Path to your Push Key .p8 file.').option('--provisioning-profile-path <.mobileprovision>', 'Path to your Provisioning Profile.').option('--public-url <url>', 'The URL of an externally hosted manifest (for self-hosted apps).').option('--skip-credentials-check', 'Skip checking credentials.').option('--skip-workflow-check', 'Skip warning about build service bare workflow limitations.').description('Build a standalone IPA for your project, signed and ready for submission to the Apple App Store.').asyncActionProjectDir(async (projectDir, options) => {
    if (!options.skipWorkflowCheck) {
      if (await maybeBailOnWorkflowWarning({
        projectDir,
        platform: 'ios',
        nonInteractive: program.nonInteractive
      })) {
        return;
      }
    }

    if (options.publicUrl && !_xdl().UrlUtils.isHttps(options.publicUrl)) {
      throw new (_CommandError().default)('INVALID_PUBLIC_URL', '--public-url must be a valid HTTPS URL.');
    }

    let channelRe = new RegExp(/^[a-z\d][a-z\d._-]*$/);

    if (!channelRe.test(options.releaseChannel)) {
      _log().default.error('Release channel name can only contain lowercase letters, numbers and special characters . _ and -');

      process.exit(1);
    }

    options.type = await (0, _utils().askBuildType)(options.type, {
      archive: 'Deploy the build to the store',
      simulator: 'Run the build on a simulator'
    });
    const iosBuilder = new (_IOSBuilder().default)(projectDir, options);
    return iosBuilder.command();
  }, {
    checkConfig: true
  });
  program.command('build:android [project-dir]').alias('ba').option('-c, --clear-credentials', 'Clear stored credentials.').option('--release-channel <channel-name>', 'Pull from specified release channel.', 'default').option('--no-publish', 'Disable automatic publishing before building.').option('--no-wait', 'Exit immediately after triggering build.').option('--keystore-path <app.jks>', 'Path to your Keystore.').option('--keystore-alias <alias>', 'Keystore Alias').option('--generate-keystore', '[deprecated] Generate Keystore if one does not exist').option('--public-url <url>', 'The URL of an externally hosted manifest (for self-hosted apps)').option('--skip-workflow-check', 'Skip warning about build service bare workflow limitations.').option('-t --type <build>', 'Type of build: [app-bundle|apk].').description('Build a standalone APK or App Bundle for your project, signed and ready for submission to the Google Play Store.').asyncActionProjectDir(async (projectDir, options) => {
    if (options.generateKeystore) {
      _log().default.warn(`The --generate-keystore flag is deprecated and does not do anything. A Keystore will always be generated on the Expo servers if it's missing.`);
    }

    if (!options.skipWorkflowCheck) {
      if (await maybeBailOnWorkflowWarning({
        projectDir,
        platform: 'android',
        nonInteractive: program.nonInteractive
      })) {
        return;
      }
    }

    if (options.publicUrl && !_xdl().UrlUtils.isHttps(options.publicUrl)) {
      throw new (_CommandError().default)('INVALID_PUBLIC_URL', '--public-url must be a valid HTTPS URL.');
    }

    let channelRe = new RegExp(/^[a-z\d][a-z\d._-]*$/);

    if (!channelRe.test(options.releaseChannel)) {
      _log().default.error('Release channel name can only contain lowercase letters, numbers and special characters . _ and -');

      process.exit(1);
    }

    options.type = await (0, _utils().askBuildType)(options.type, {
      apk: 'Build a package to deploy to the store or install directly on Android devices',
      'app-bundle': 'Build an optimized bundle for the store'
    });
    const androidBuilder = new (_AndroidBuilder().default)(projectDir, options);
    return androidBuilder.command();
  }, {
    checkConfig: true
  });
  program.command('build:web [project-dir]').option('-c, --clear', 'Clear all cached build files and assets.').option('--no-pwa', 'Prevent webpack from generating the manifest.json and injecting meta into the index.html head.').option('-d, --dev', 'Turns dev flag on before bundling').description('Build a production bundle for your project, compressed and ready for deployment.').asyncActionProjectDir((projectDir, options) => {
    return _xdl().Webpack.bundleAsync(projectDir, { ...options,
      dev: typeof options.dev === 'undefined' ? false : options.dev
    });
  });
  program.command('build:status [project-dir]').alias('bs').option('--public-url <url>', 'The URL of an externally hosted manifest (for self-hosted apps).').description(`Gets the status of a current (or most recently finished) build for your project.`).asyncActionProjectDir(async (projectDir, options) => {
    if (options.publicUrl && !_xdl().UrlUtils.isHttps(options.publicUrl)) {
      throw new (_CommandError().default)('INVALID_PUBLIC_URL', '--public-url must be a valid HTTPS URL.');
    }

    const builder = new (_BaseBuilder().default)(projectDir, options);
    return builder.commandCheckStatus();
  });
}
//# sourceMappingURL=index.js.map