"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.downloadFile = downloadFile;
exports.runFastlaneAsync = runFastlaneAsync;

function _stream() {
  const data = _interopRequireDefault(require("stream"));

  _stream = function () {
    return data;
  };

  return data;
}

function _util() {
  const data = require("util");

  _util = function () {
    return data;
  };

  return data;
}

function _xdl() {
  const data = require("@expo/xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _got() {
  const data = _interopRequireDefault(require("got"));

  _got = function () {
    return data;
  };

  return data;
}

function _progress() {
  const data = _interopRequireDefault(require("progress"));

  _progress = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const {
  spawnAsyncThrowError
} = _xdl().ExponentTools;

const pipeline = (0, _util().promisify)(_stream().default.pipeline);

async function downloadFile(url, dest) {
  let bar;
  let transferredSoFar = 0;

  const downloadStream = _got().default.stream(url).on('downloadProgress', progress => {
    if (!bar) {
      bar = new (_progress().default)('Downloading [:bar] :percent :etas', {
        complete: '=',
        incomplete: ' ',
        total: progress.total
      });
    }

    bar.tick(progress.transferred - transferredSoFar);
    transferredSoFar = progress.transferred;
  });

  await pipeline(downloadStream, _fsExtra().default.createWriteStream(dest));
  return dest;
}

async function runFastlaneAsync(program, args, {
  appleId,
  appleIdPassword,
  appleTeamId,
  itcTeamId,
  companyName
}, pipeToLogger = false) {
  const pipeToLoggerOptions = pipeToLogger ? {
    pipeToLogger: {
      stdout: true
    }
  } : {
    stdio: [0, 1, 'pipe']
  };
  const fastlaneData = appleId && appleIdPassword ? {
    FASTLANE_USER: appleId,
    FASTLANE_PASSWORD: appleIdPassword,
    FASTLANE_DONT_STORE_PASSWORD: '1',
    FASTLANE_TEAM_ID: appleTeamId,
    ...(itcTeamId && {
      FASTLANE_ITC_TEAM_ID: itcTeamId
    }),
    ...(companyName && {
      PRODUCE_COMPANY_NAME: companyName
    })
  } : {};
  const env = { ...process.env,
    ...fastlaneData
  };
  const spawnOptions = { ...pipeToLoggerOptions,
    env
  };
  const {
    stderr
  } = await spawnAsyncThrowError(program, args, spawnOptions);
  const res = JSON.parse(stderr);

  if (res.result !== 'failure') {
    return res;
  } else {
    var _res$rawDump$message, _res$rawDump, _res$rawDump2;

    let message = res.reason !== 'Unknown reason' ? res.reason : (_res$rawDump$message = (_res$rawDump = res.rawDump) === null || _res$rawDump === void 0 ? void 0 : _res$rawDump.message) !== null && _res$rawDump$message !== void 0 ? _res$rawDump$message : 'Unknown error when running fastlane';
    message = `${message}${(res === null || res === void 0 ? void 0 : (_res$rawDump2 = res.rawDump) === null || _res$rawDump2 === void 0 ? void 0 : _res$rawDump2.backtrace) ? `\n${res.rawDump.backtrace.map(i => `    ${i}`).join('\n')}` : ''}`;
    throw new Error(message);
  }
}
//# sourceMappingURL=utils.js.map