{"version":3,"sources":["../../../../../src/commands/upload/submission-service/archive-source/ArchiveTypeSource.ts"],"names":["ArchiveTypeSourceType","getArchiveTypeAsync","source","location","sourceType","infer","handleInferSourceAsync","parameter","handleParameterSourceAsync","prompt","handlePromptSourceAsync","_source","inferredArchiveType","inferArchiveTypeFromLocation","log","warn","archiveType","archiveTypeRaw","name","type","message","choices","value","ArchiveType","apk","aab","default","endsWith"],"mappings":"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","sourcesContent":["import prompt from '../../../../prompt';\nimport log from '../../../../log';\nimport { ArchiveType } from '../android/AndroidSubmissionConfig';\n\nenum ArchiveTypeSourceType {\n  infer,\n  parameter,\n  prompt,\n}\n\ninterface ArchiveTypeSourceBase {\n  sourceType: ArchiveTypeSourceType;\n}\n\ninterface ArchiveTypeInferSource extends ArchiveTypeSourceBase {\n  sourceType: ArchiveTypeSourceType.infer;\n}\n\ninterface ArchiveTypeParameterSource extends ArchiveTypeSourceBase {\n  sourceType: ArchiveTypeSourceType.parameter;\n  archiveType: ArchiveType;\n}\n\ninterface ArchiveTypePromptSource extends ArchiveTypeSourceBase {\n  sourceType: ArchiveTypeSourceType.prompt;\n}\n\nexport type ArchiveTypeSource =\n  | ArchiveTypeInferSource\n  | ArchiveTypeParameterSource\n  | ArchiveTypePromptSource;\n\nasync function getArchiveTypeAsync(\n  source: ArchiveTypeSource,\n  location: string\n): Promise<ArchiveType> {\n  switch (source.sourceType) {\n    case ArchiveTypeSourceType.infer:\n      return handleInferSourceAsync(source, location);\n    case ArchiveTypeSourceType.parameter:\n      return handleParameterSourceAsync(source, location);\n    case ArchiveTypeSourceType.prompt:\n      return handlePromptSourceAsync(source, location);\n  }\n}\n\nasync function handleInferSourceAsync(\n  _source: ArchiveTypeInferSource,\n  location: string\n): Promise<ArchiveType> {\n  const inferredArchiveType = inferArchiveTypeFromLocation(location);\n  if (inferredArchiveType) {\n    return inferredArchiveType;\n  } else {\n    log.warn(\"We couldn't autodetect the archive type\");\n    return getArchiveTypeAsync({ sourceType: ArchiveTypeSourceType.prompt }, location);\n  }\n}\n\nasync function handleParameterSourceAsync(\n  source: ArchiveTypeParameterSource,\n  location: string\n): Promise<ArchiveType> {\n  const inferredArchiveType = inferArchiveTypeFromLocation(location);\n  if (inferredArchiveType) {\n    if (source.archiveType === inferredArchiveType) {\n      return source.archiveType;\n    } else {\n      log.warn(\n        `The archive seems to be .${inferredArchiveType} and you passed: --type ${source.archiveType}`\n      );\n      return getArchiveTypeAsync({ sourceType: ArchiveTypeSourceType.prompt }, location);\n    }\n  } else {\n    return source.archiveType;\n  }\n}\n\nasync function handlePromptSourceAsync(\n  _source: ArchiveTypePromptSource,\n  location: string\n): Promise<ArchiveType> {\n  const inferredArchiveType = inferArchiveTypeFromLocation(location);\n  const { archiveType: archiveTypeRaw } = await prompt({\n    name: 'archiveType',\n    type: 'list',\n    message: \"What's the archive type?\",\n    choices: [\n      { name: 'APK', value: ArchiveType.apk },\n      { name: 'AAB', value: ArchiveType.aab },\n    ],\n    ...(inferredArchiveType && { default: inferredArchiveType }),\n  });\n  return archiveTypeRaw as ArchiveType;\n}\n\ntype ArchiveInferredType = ArchiveType | null;\n\nfunction inferArchiveTypeFromLocation(location: string): ArchiveInferredType {\n  if (location.endsWith('.apk')) {\n    return ArchiveType.apk;\n  } else if (location.endsWith('.aab')) {\n    return ArchiveType.aab;\n  } else {\n    return null;\n  }\n}\n\nexport { ArchiveTypeSourceType, getArchiveTypeAsync };\n"],"file":"ArchiveTypeSource.js"}