"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.waitForBuildEndAsync = waitForBuildEndAsync;
exports.makeProjectTarballAsync = makeProjectTarballAsync;
exports.printBuildTable = printBuildTable;

function _spawnAsync() {
  const data = _interopRequireDefault(require("@expo/spawn-async"));

  _spawnAsync = function () {
    return data;
  };

  return data;
}

function _delayAsync() {
  const data = _interopRequireDefault(require("delay-async"));

  _delayAsync = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _ora() {
  const data = _interopRequireDefault(require("ora"));

  _ora = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _cliTable() {
  const data = require("../utils/cli-table");

  _cliTable = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function waitForBuildEndAsync(client, projectId, buildId, {
  timeoutSec = 1800,
  intervalSec = 30
} = {}) {
  var _buildInfo$artifacts$, _buildInfo$artifacts;

  (0, _log().default)('Waiting for build to complete. You can press Ctrl+C to exit.');
  const spinner = (0, _ora().default)().start();
  let time = new Date().getTime();
  const endTime = time + timeoutSec * 1000;

  while (time <= endTime) {
    const buildInfo = await client.getAsync(`projects/${projectId}/builds/${buildId}`);

    switch (buildInfo.status) {
      case 'finished':
        spinner.succeed('Build finished.');
        return (_buildInfo$artifacts$ = (_buildInfo$artifacts = buildInfo.artifacts) === null || _buildInfo$artifacts === void 0 ? void 0 : _buildInfo$artifacts.buildUrl) !== null && _buildInfo$artifacts$ !== void 0 ? _buildInfo$artifacts$ : '';

      case 'in-queue':
        spinner.text = 'Build queued...';
        break;

      case 'in-progress':
        spinner.text = 'Build in progress...';
        break;

      case 'errored':
        spinner.fail('Build failed.');
        throw new Error(`Standalone build failed!`);

      default:
        spinner.warn('Unknown status.');
        throw new Error(`Unknown status: ${buildInfo} - aborting!`);
    }

    time = new Date().getTime();
    await (0, _delayAsync().default)(intervalSec * 1000);
  }

  spinner.warn('Timed out.');
  throw new Error('Timeout reached! It is taking longer than expected to finish the build, aborting...');
}

async function makeProjectTarballAsync(tarPath) {
  const spinner = (0, _ora().default)('Making project tarball').start();
  const changes = (await (0, _spawnAsync().default)('git', ['status', '-s'])).stdout;

  if (changes.length > 0) {
    spinner.fail('Could not make project tarball');
    throw new Error('Please commit all files before trying to build your project. Aborting...');
  }

  await (0, _spawnAsync().default)('git', ['archive', '--format=tar.gz', '--prefix', 'project/', '-o', tarPath, 'HEAD']);
  spinner.succeed('Project tarball created.');
  const {
    size
  } = await _fsExtra().default.stat(tarPath);
  return size;
}

function printBuildTable(builds) {
  const headers = ['platform', 'status', 'artifacts'];
  const colWidths = [10, 15, 80];
  const refactoredBuilds = builds.map(build => {
    var _build$artifacts$buil, _build$artifacts;

    return { ...build,
      artifacts: (_build$artifacts$buil = (_build$artifacts = build.artifacts) === null || _build$artifacts === void 0 ? void 0 : _build$artifacts.buildUrl) !== null && _build$artifacts$buil !== void 0 ? _build$artifacts$buil : 'not available'
    };
  });
  const buildTable = (0, _cliTable().printTableJsonArray)(headers, refactoredBuilds, colWidths);
  console.log(buildTable);
}
//# sourceMappingURL=utils.js.map