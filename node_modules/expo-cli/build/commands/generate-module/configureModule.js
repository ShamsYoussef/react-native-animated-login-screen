"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = configureModule;

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _klawSync() {
  const data = _interopRequireDefault(require("klaw-sync"));

  _klawSync = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const asyncForEach = async (array, callback) => {
  for (let index = 0; index < array.length; index++) {
    await callback(array[index], index, array);
  }
};

async function removeFiles(directoryPath, filenames) {
  await asyncForEach(filenames, async filename => await _fsExtra().default.remove(_path().default.resolve(directoryPath, filename)));
}
/**
 * Renames files names
 * @param directoryPath - directory that holds files to be renamed
 * @param extensions - array of extensions for files that would be renamed, must be provided with leading dot or empty for no extension, e.g. ['.html', '']
 * @param renamings - array of filenames and their replacers
 */


const renameFilesWithExtensions = async (directoryPath, extensions, renamings) => {
  await asyncForEach(renamings, async ({
    from,
    to
  }) => await asyncForEach(extensions, async extension => {
    const fromFilename = `${from}${extension}`;

    if (!_fsExtra().default.existsSync(_path().default.join(directoryPath, fromFilename))) {
      return;
    }

    const toFilename = `${to}${extension}`;
    await _fsExtra().default.rename(_path().default.join(directoryPath, fromFilename), _path().default.join(directoryPath, toFilename));
  }));
};
/**
 * Enters each file recursively in provided dir and replaces content by invoking provided callback function
 * @param directoryPath - root directory
 * @param replaceFunction - function that converts current content into something different
 */


const replaceContents = async (directoryPath, replaceFunction) => {
  for (let file of (0, _klawSync().default)(directoryPath, {
    nodir: true
  })) {
    replaceContent(file.path, replaceFunction);
  }
};
/**
 * Replaces content in file
 * @param filePath - provided file
 * @param replaceFunction - function that converts current content into something different
 */


const replaceContent = async (filePath, replaceFunction) => {
  const content = await _fsExtra().default.readFile(filePath, 'utf8');
  const newContent = replaceFunction(content);

  if (newContent !== content) {
    await _fsExtra().default.writeFile(filePath, newContent);
  }
};
/**
 * Removes all empty subdirs up to and including dirPath
 * Recursively enters all subdirs and removes them if one is empty or cantained only empty subdirs
 * @param dirPath - directory path that is being inspected
 * @returns whether the given base directory and any empty subdirectories were deleted or not
 */


const removeUponEmptyOrOnlyEmptySubdirs = async dirPath => {
  const contents = await _fsExtra().default.readdir(dirPath);
  const results = await Promise.all(contents.map(async file => {
    const filePath = _path().default.join(dirPath, file);

    const fileStats = await _fsExtra().default.lstat(filePath);
    return fileStats.isDirectory() && (await removeUponEmptyOrOnlyEmptySubdirs(filePath));
  }));
  const isRemovable = results.reduce((acc, current) => acc && current, true);

  if (isRemovable) {
    await _fsExtra().default.remove(dirPath);
  }

  return isRemovable;
};
/**
 * Prepares iOS part, mainly by renaming all files and some template word in files
 * Versioning is done automatically based on package.json from JS/TS part
 * @param modulePath - module directory
 * @param configuration - naming configuration
 */


async function configureIOS(modulePath, {
  podName,
  jsPackageName,
  viewManager
}) {
  const iosPath = _path().default.join(modulePath, 'ios'); // remove ViewManager from template


  if (!viewManager) {
    await removeFiles(_path().default.join(iosPath, 'EXModuleTemplate'), [`EXModuleTemplateView.h`, `EXModuleTemplateView.m`, `EXModuleTemplateViewManager.h`, `EXModuleTemplateViewManager.m`]);
  }

  await renameFilesWithExtensions(_path().default.join(iosPath, 'EXModuleTemplate'), ['.h', '.m'], [{
    from: 'EXModuleTemplateModule',
    to: `${podName}Module`
  }, {
    from: 'EXModuleTemplateView',
    to: `${podName}View`
  }, {
    from: 'EXModuleTemplateViewManager',
    to: `${podName}ViewManager`
  }]);
  await renameFilesWithExtensions(iosPath, ['', '.podspec'], [{
    from: 'EXModuleTemplate',
    to: `${podName}`
  }]);
  await replaceContents(iosPath, singleFileContent => singleFileContent.replace(/EXModuleTemplate/g, podName).replace(/ExpoModuleTemplate/g, jsPackageName));
}
/**
 * Prepares Android part, mainly by renaming all files and template words in files
 * Sets all versions in Gradle to 1.0.0
 * @param modulePath - module directory
 * @param configuration - naming configuration
 */


async function configureAndroid(modulePath, {
  javaPackage,
  jsPackageName,
  viewManager
}) {
  const androidPath = _path().default.join(modulePath, 'android');

  const sourceFilesPath = _path().default.join(androidPath, 'src', 'main', 'kotlin', 'expo', 'modules', 'template');

  const destinationFilesPath = _path().default.join(androidPath, 'src', 'main', 'kotlin', ...javaPackage.split('.')); // remove ViewManager from template


  if (!viewManager) {
    removeFiles(sourceFilesPath, [`ModuleTemplateView.kt`, `ModuleTemplateViewManager.kt`]);
    replaceContent(_path().default.join(sourceFilesPath, 'ModuleTemplatePackage.kt'), packageContent => packageContent.replace(/(^\s+)+(^.*?){1}createViewManagers[\s\W\w]+?\}/m, '').replace(/^.*ViewManager$/, ''));
  }

  await _fsExtra().default.mkdirp(destinationFilesPath);
  await _fsExtra().default.copy(sourceFilesPath, destinationFilesPath); // Remove leaf directory content

  await _fsExtra().default.remove(sourceFilesPath); // Cleanup all empty subdirs up to provided rootDir

  await removeUponEmptyOrOnlyEmptySubdirs(_path().default.join(androidPath, 'src', 'main', 'kotlin', 'expo'));
  const moduleName = jsPackageName.startsWith('Expo') ? jsPackageName.substring(4) : jsPackageName;
  await replaceContents(androidPath, singleFileContent => singleFileContent.replace(/expo\.modules\.template/g, javaPackage).replace(/ModuleTemplate/g, moduleName).replace(/ExpoModuleTemplate/g, jsPackageName));
  await replaceContent(_path().default.join(androidPath, 'build.gradle'), gradleContent => gradleContent.replace(/\bversion = ['"][\w.-]+['"]/, "version = '1.0.0'").replace(/versionCode \d+/, 'versionCode 1').replace(/versionName ['"][\w.-]+['"]/, "versionName '1.0.0'"));
  await renameFilesWithExtensions(destinationFilesPath, ['.kt'], [{
    from: 'ModuleTemplateModule',
    to: `${moduleName}Module`
  }, {
    from: 'ModuleTemplatePackage',
    to: `${moduleName}Package`
  }, {
    from: 'ModuleTemplateView',
    to: `${moduleName}View`
  }, {
    from: 'ModuleTemplateViewManager',
    to: `${moduleName}ViewManager`
  }]);
}
/**
 * Prepares TS part.
 * @param modulePath - module directory
 * @param configuration - naming configuration
 */


async function configureTS(modulePath, {
  jsPackageName,
  viewManager
}) {
  const moduleNameWithoutExpoPrefix = jsPackageName.startsWith('Expo') ? jsPackageName.substr(4) : 'Unimodule';

  const tsPath = _path().default.join(modulePath, 'src'); // remove View Manager from template


  if (!viewManager) {
    await removeFiles(_path().default.join(tsPath), ['ExpoModuleTemplateView.tsx', 'ExpoModuleTemplateNativeView.ts', 'ExpoModuleTemplateNativeView.web.tsx']);
    await replaceContent(_path().default.join(tsPath, 'ModuleTemplate.ts'), fileContent => fileContent.replace(/(^\s+)+(^.*?){1}ExpoModuleTemplateView.*$/m, ''));
  }

  await renameFilesWithExtensions(_path().default.join(tsPath, '__tests__'), ['.ts'], [{
    from: 'ModuleTemplate-test',
    to: `${moduleNameWithoutExpoPrefix}-test`
  }]);
  await renameFilesWithExtensions(tsPath, ['.tsx', '.ts'], [{
    from: 'ExpoModuleTemplateView',
    to: `${jsPackageName}View`
  }, {
    from: 'ExpoModuleTemplateNativeView',
    to: `${jsPackageName}NativeView`
  }, {
    from: 'ExpoModuleTemplateNativeView.web',
    to: `${jsPackageName}NativeView.web`
  }, {
    from: 'ExpoModuleTemplate',
    to: jsPackageName
  }, {
    from: 'ExpoModuleTemplate.web',
    to: `${jsPackageName}.web`
  }, {
    from: 'ModuleTemplate',
    to: moduleNameWithoutExpoPrefix
  }, {
    from: 'ModuleTemplate.types',
    to: `${moduleNameWithoutExpoPrefix}.types`
  }]);
  await replaceContents(tsPath, singleFileContent => singleFileContent.replace(/ExpoModuleTemplate/g, jsPackageName).replace(/ModuleTemplate/g, moduleNameWithoutExpoPrefix));
}
/**
 * Prepares files for npm (package.json and README.md).
 * @param modulePath - module directory
 * @param configuration - naming configuration
 */


async function configureNPM(modulePath, {
  npmModuleName,
  podName,
  jsPackageName
}) {
  const moduleNameWithoutExpoPrefix = jsPackageName.startsWith('Expo') ? jsPackageName.substr(4) : 'Unimodule';
  await replaceContent(_path().default.join(modulePath, 'package.json'), singleFileContent => singleFileContent.replace(/expo-module-template/g, npmModuleName).replace(/"version": "[\w.-]+"/, '"version": "1.0.0"').replace(/ExpoModuleTemplate/g, jsPackageName).replace(/ModuleTemplate/g, moduleNameWithoutExpoPrefix));
  await replaceContent(_path().default.join(modulePath, 'README.md'), readmeContent => readmeContent.replace(/expo-module-template/g, npmModuleName).replace(/ExpoModuleTemplate/g, jsPackageName).replace(/EXModuleTemplate/g, podName));
}
/**
 * Configures TS, Android and iOS parts of generated module mostly by applying provided renamings.
 * @param modulePath - module directory
 * @param configuration - naming configuration
 */


async function configureModule(newModulePath, configuration) {
  await configureNPM(newModulePath, configuration);
  await configureTS(newModulePath, configuration);
  await configureAndroid(newModulePath, configuration);
  await configureIOS(newModulePath, configuration);
}
//# sourceMappingURL=configureModule.js.map