"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.action = action;
exports.default = _default;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _simpleSpinner() {
  const data = _interopRequireDefault(require("@expo/simple-spinner"));

  _simpleSpinner = function () {
    return data;
  };

  return data;
}

function _xdl() {
  const data = require("@expo/xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _fs() {
  const data = _interopRequireDefault(require("fs"));

  _fs = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _terminalLink() {
  const data = _interopRequireDefault(require("terminal-link"));

  _terminalLink = function () {
    return data;
  };

  return data;
}

function _exit() {
  const data = require("../exit");

  _exit = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _sendTo() {
  const data = _interopRequireDefault(require("../sendTo"));

  _sendTo = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function action(projectDir, options = {}) {
  var _options$target;

  let channelRe = new RegExp(/^[a-z\d][a-z\d._-]*$/);

  if (options.releaseChannel && !channelRe.test(options.releaseChannel)) {
    _log().default.error('Release channel name can only contain lowercase letters, numbers and special characters . _ and -');

    process.exit(1);
  }

  const {
    exp,
    pkg
  } = (0, _config().getConfig)(projectDir, {
    skipSDKVersionRequirement: true
  });

  if (pkg.dependencies['expo-updates'] && pkg.dependencies['expokit']) {
    _log().default.warn(`Warning: You have both the ${_chalk().default.bold('expokit')} and ${_chalk().default.bold('expo-updates')} packages installed in package.json.`);

    _log().default.warn(`These two packages are incompatible and ${_chalk().default.bold('publishing updates with expo-updates will not work if expokit is installed.')}`);

    _log().default.warn(`If you intend to use ${_chalk().default.bold('expo-updates')}, please remove ${_chalk().default.bold('expokit')} from your dependencies.`);
  }

  const hasOptimized = _fs().default.existsSync(_path().default.join(projectDir, '/.expo-shared/assets.json'));

  const nonInteractive = options.parent && options.parent.nonInteractive;

  if (!hasOptimized && !nonInteractive) {
    _log().default.warn('Warning: Your project may contain unoptimized image assets. Smaller image sizes can improve app performance.');

    _log().default.warn(`To compress the images in your project, abort publishing and run ${_chalk().default.bold('npx expo-optimize')}.`);
  }

  const target = (_options$target = options.target) !== null && _options$target !== void 0 ? _options$target : (0, _config().getDefaultTarget)(projectDir);
  const status = await _xdl().Project.currentStatus(projectDir);
  let shouldStartOurOwn = false;

  if (status === 'running') {
    var _packagerInfo$target;

    const packagerInfo = await _xdl().ProjectSettings.readPackagerInfoAsync(projectDir);
    const runningPackagerTarget = (_packagerInfo$target = packagerInfo.target) !== null && _packagerInfo$target !== void 0 ? _packagerInfo$target : 'managed';

    if (target !== runningPackagerTarget) {
      (0, _log().default)('Found an existing Expo CLI instance running for this project but the target did not match.');
      await _xdl().Project.stopAsync(projectDir);
      (0, _log().default)('Starting a new Expo CLI instance...');
      shouldStartOurOwn = true;
    }
  } else {
    (0, _log().default)('Unable to find an existing Expo CLI instance for this directory; starting a new one...');
    shouldStartOurOwn = true;
  }

  let startedOurOwn = false;

  if (shouldStartOurOwn) {
    (0, _exit().installExitHooks)(projectDir);
    const startOpts = {
      reset: options.clear,
      nonPersistent: true,
      target
    };

    if (options.maxWorkers) {
      startOpts.maxWorkers = options.maxWorkers;
    }

    await _xdl().Project.startAsync(projectDir, startOpts, !options.quiet);
    startedOurOwn = true;
  }

  let recipient = await _sendTo().default.getRecipient(options.sendTo);
  (0, _log().default)(`Publishing to channel '${options.releaseChannel}'...`);
  const {
    args: {
      sdkVersion
    }
  } = await _xdl().Exp.getPublishInfoAsync(projectDir);
  const buildStatus = await _xdl().Project.getBuildStatusAsync(projectDir, {
    platform: 'all',
    current: true,
    releaseChannel: options.releaseChannel,
    sdkVersion
  });

  if ('userHasBuiltExperienceBefore' in buildStatus && buildStatus.userHasBuiltExperienceBefore && !buildStatus.userHasBuiltAppBefore && !options.duringBuild && !exp.isDetached) {
    _log().default.warn('We noticed that you have not built a standalone app with this SDK version and release channel before. ' + 'Remember that OTA updates will only work for builds with matching SDK versions and release channels. ' + 'Read more here: https://docs.expo.io/workflow/publishing/#limitations');
  }

  if (options.quiet) {
    _simpleSpinner().default.start();
  }

  let result;

  try {
    result = await _xdl().Project.publishAsync(projectDir, {
      releaseChannel: options.releaseChannel
    });
    let url = result.url;

    if (options.quiet) {
      _simpleSpinner().default.stop();
    }

    (0, _log().default)('Publish complete');

    _log().default.newLine();

    let exampleManifestUrl = getExampleManifestUrl(url, exp.sdkVersion);

    if (exampleManifestUrl) {
      (0, _log().default)(`The manifest URL is: ${(0, _terminalLink().default)(url, exampleManifestUrl)}. ${(0, _terminalLink().default)('Learn more.', 'https://expo.fyi/manifest-url')}`);
    } else {
      (0, _log().default)(`The manifest URL is: ${(0, _terminalLink().default)(url, url)}. ${(0, _terminalLink().default)('Learn more.', 'https://expo.fyi/manifest-url')}`);
    }

    if (target === 'managed') {
      // TODO: replace with websiteUrl from server when it is available, if that makes sense.
      let websiteUrl = url.replace('exp.host', 'expo.io');
      (0, _log().default)(`The project page is: ${(0, _terminalLink().default)(websiteUrl, websiteUrl)}. ${(0, _terminalLink().default)('Learn more.', 'https://expo.fyi/project-page')}`);

      if (recipient) {
        await _sendTo().default.sendUrlAsync(websiteUrl, recipient);
      }
    } else {// This seems pointless in bare?? Leaving it out
      // if (recipient) {
      //   await sendTo.sendUrlAsync(url, recipient);
      // }
    }
  } finally {
    if (startedOurOwn) {
      await _xdl().Project.stopAsync(projectDir);
    }
  }

  return result;
}

function getExampleManifestUrl(url, sdkVersion) {
  if (!sdkVersion) {
    return null;
  }

  if (url.includes('release-channel') && url.includes('?release-channel')) {
    return url.replace('?release-channel', '/index.exp?release-channel') + `&sdkVersion=${sdkVersion}`;
  } else if (url.includes('?') && !url.includes('release-channel')) {
    // This is the only relevant url query param we are aware of at the time of
    // writing this code, so if there is some other param included we don't know
    // how to deal with it and log nothing.
    return null;
  } else {
    return `${url}/index.exp?sdkVersion=${sdkVersion}`;
  }
}

function _default(program) {
  program.command('publish [project-dir]').alias('p').description('Publishes your project to exp.host').option('-q, --quiet', 'Suppress verbose output from the Metro bundler.').option('-s, --send-to [dest]', 'A phone number or email address to send a link to').option('-c, --clear', 'Clear the Metro bundler cache').option('-t, --target [env]', 'Target environment for which this publish is intended. Options are `managed` or `bare`.') // TODO(anp) set a default for this dynamically based on whether we're inside a container?
  .option('--max-workers [num]', 'Maximum number of tasks to allow Metro to spawn.').option('--release-channel <release channel>', "The release channel to publish to. Default is 'default'.", 'default').asyncActionProjectDir(action);
}
//# sourceMappingURL=publish.js.map