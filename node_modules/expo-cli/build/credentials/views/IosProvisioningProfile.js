"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateProfileWithoutApple = validateProfileWithoutApple;
exports.getAppleInfo = getAppleInfo;
exports.configureAndUpdateProvisioningProfile = configureAndUpdateProvisioningProfile;
exports.getProvisioningProfileFromParams = getProvisioningProfileFromParams;
exports.useProvisioningProfileFromParams = useProvisioningProfileFromParams;
exports.CreateOrReuseProvisioningProfile = exports.UseExistingProvisioningProfile = exports.CreateProvisioningProfile = exports.RemoveProvisioningProfile = void 0;

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _ora() {
  const data = _interopRequireDefault(require("ora"));

  _ora = function () {
    return data;
  };

  return data;
}

function _plist() {
  const data = _interopRequireDefault(require("@expo/plist"));

  _plist = function () {
    return data;
  };

  return data;
}

function _xdl() {
  const data = require("@expo/xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _prompt() {
  const data = _interopRequireDefault(require("../../prompt"));

  _prompt = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _credentials() {
  const data = require("../credentials");

  _credentials = function () {
    return data;
  };

  return data;
}

function _promptForCredentials() {
  const data = require("../actions/promptForCredentials");

  _promptForCredentials = function () {
    return data;
  };

  return data;
}

function _list() {
  const data = require("../actions/list");

  _list = function () {
    return data;
  };

  return data;
}

function _appleApi() {
  const data = require("../../appleApi");

  _appleApi = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class RemoveProvisioningProfile {
  constructor(shouldRevoke = false, nonInteractive = false) {
    _defineProperty(this, "shouldRevoke", void 0);

    _defineProperty(this, "nonInteractive", void 0);

    this.shouldRevoke = shouldRevoke;
    this.nonInteractive = nonInteractive;
  }

  async open(ctx) {
    const selected = await selectProfileFromExpo(ctx.ios.credentials);

    if (selected) {
      await this.removeSpecific(ctx, selected);
      (0, _log().default)(_chalk().default.green(`Successfully removed Provisioning Profile for ${selected.experienceName} (${selected.bundleIdentifier})`));
    }

    return null;
  }

  async removeSpecific(ctx, selected) {
    (0, _log().default)('Removing Provisioning Profile...\n');
    await ctx.ios.deleteProvisioningProfile(selected.experienceName, selected.bundleIdentifier);
    let shouldRevoke = this.shouldRevoke;

    if (!shouldRevoke && !this.nonInteractive) {
      const {
        revoke
      } = await (0, _prompt().default)([{
        type: 'confirm',
        name: 'revoke',
        message: 'Do you also want to revoke it on Apple Developer Portal?'
      }]);
      shouldRevoke = revoke;
    }

    if (shouldRevoke) {
      await ctx.ensureAppleCtx();
      const ppManager = new (_appleApi().ProvisioningProfileManager)(ctx.appleCtx);
      await ppManager.revoke(selected.bundleIdentifier);
    }
  }

}

exports.RemoveProvisioningProfile = RemoveProvisioningProfile;

class CreateProvisioningProfile {
  constructor(options) {
    var _options$nonInteracti;

    _defineProperty(this, "_experienceName", void 0);

    _defineProperty(this, "_bundleIdentifier", void 0);

    _defineProperty(this, "_distCert", void 0);

    _defineProperty(this, "_nonInteractive", void 0);

    const {
      experienceName,
      bundleIdentifier,
      distCert
    } = options;
    this._experienceName = experienceName;
    this._bundleIdentifier = bundleIdentifier;
    this._distCert = distCert;
    this._nonInteractive = (_options$nonInteracti = options.nonInteractive) !== null && _options$nonInteracti !== void 0 ? _options$nonInteracti : false;
  }

  async create(ctx) {
    const provisioningProfile = await this.provideOrGenerate(ctx);
    const appleTeam = ctx.hasAppleCtx() ? ctx.appleCtx.team : await (0, _promptForCredentials().getCredentialsFromUser)(_credentials().appleTeamSchema);

    if (!appleTeam) {
      throw new Error('Must provide a valid Apple Team Id');
    }

    return await ctx.ios.updateProvisioningProfile(this._experienceName, this._bundleIdentifier, provisioningProfile, appleTeam);
  }

  async open(ctx) {
    await this.create(ctx);
    (0, _log().default)(_chalk().default.green('Successfully created Provisioning Profile\n'));
    const appCredentials = ctx.ios.credentials.appCredentials.find(app => app.experienceName === this._experienceName && app.bundleIdentifier === this._bundleIdentifier);
    (0, _list().displayIosAppCredentials)(appCredentials);
    (0, _log().default)();
    return null;
  }

  async provideOrGenerate(ctx) {
    if (!this._nonInteractive) {
      const userProvided = await (0, _promptForCredentials().askForUserProvided)(_credentials().provisioningProfileSchema);

      if (userProvided) {
        // userProvided profiles don't come with ProvisioningProfileId's (only accessible from Apple Portal API)
        (0, _log().default)(_chalk().default.yellow('Provisioning profile: Unable to validate uploaded profile.'));
        return userProvided;
      }
    }

    return await generateProvisioningProfile(ctx, this._bundleIdentifier, this._distCert);
  }

}

exports.CreateProvisioningProfile = CreateProvisioningProfile;

class UseExistingProvisioningProfile {
  constructor(options) {
    _defineProperty(this, "_experienceName", void 0);

    _defineProperty(this, "_bundleIdentifier", void 0);

    _defineProperty(this, "_distCert", void 0);

    const {
      experienceName,
      bundleIdentifier,
      distCert
    } = options;
    this._experienceName = experienceName;
    this._bundleIdentifier = bundleIdentifier;
    this._distCert = distCert;
  }

  async open(ctx) {
    await ctx.ensureAppleCtx();
    const selected = await selectProfileFromApple(ctx.appleCtx, this._bundleIdentifier);

    if (selected) {
      await configureAndUpdateProvisioningProfile(ctx, this._experienceName, this._bundleIdentifier, this._distCert, selected);
    }

    return null;
  }

}

exports.UseExistingProvisioningProfile = UseExistingProvisioningProfile;

class CreateOrReuseProvisioningProfile {
  constructor(options) {
    var _options$nonInteracti2;

    _defineProperty(this, "_experienceName", void 0);

    _defineProperty(this, "_bundleIdentifier", void 0);

    _defineProperty(this, "_distCert", void 0);

    _defineProperty(this, "_nonInteractive", void 0);

    const {
      experienceName,
      bundleIdentifier,
      distCert
    } = options;
    this._experienceName = experienceName;
    this._bundleIdentifier = bundleIdentifier;
    this._distCert = distCert;
    this._nonInteractive = (_options$nonInteracti2 = options.nonInteractive) !== null && _options$nonInteracti2 !== void 0 ? _options$nonInteracti2 : false;
  }

  choosePreferred(profiles) {
    // prefer the profile that already has the same dist cert associated with it
    const profileWithSameCert = profiles.find(profile => profile.certificates.some(cert => cert.id === this._distCert.certId)); // if not, just get an arbitrary profile

    return profileWithSameCert || profiles[0];
  }

  async open(ctx) {
    if (!ctx.user) {
      throw new Error(`This workflow requires you to be logged in.`);
    }

    if (!ctx.hasAppleCtx()) {
      return new CreateProvisioningProfile({
        experienceName: this._experienceName,
        bundleIdentifier: this._bundleIdentifier,
        distCert: this._distCert,
        nonInteractive: this._nonInteractive
      });
    }

    const ppManager = new (_appleApi().ProvisioningProfileManager)(ctx.appleCtx);
    const existingProfiles = await ppManager.list(this._bundleIdentifier);

    if (existingProfiles.length === 0) {
      return new CreateProvisioningProfile({
        experienceName: this._experienceName,
        bundleIdentifier: this._bundleIdentifier,
        distCert: this._distCert,
        nonInteractive: this._nonInteractive
      });
    }

    const autoselectedProfile = this.choosePreferred(existingProfiles); // autoselect creds if we find valid certs

    const confirmQuestion = {
      type: 'confirm',
      name: 'confirm',
      message: `${formatProvisioningProfileFromApple(autoselectedProfile)} \n Would you like to use this profile?`,
      pageSize: Infinity
    };

    if (!this._nonInteractive) {
      const {
        confirm
      } = await (0, _prompt().default)(confirmQuestion);

      if (!confirm) {
        return await this._createOrReuse(ctx);
      }
    }

    (0, _log().default)(`Using Provisioning Profile: ${autoselectedProfile.provisioningProfileId}`);
    await configureAndUpdateProvisioningProfile(ctx, this._experienceName, this._bundleIdentifier, this._distCert, autoselectedProfile);
    return null;
  }

  async _createOrReuse(ctx) {
    const choices = [{
      name: '[Choose existing provisioning profile] (Recommended)',
      value: 'CHOOSE_EXISTING'
    }, {
      name: '[Add a new provisioning profile]',
      value: 'GENERATE'
    }];
    const question = {
      type: 'list',
      name: 'action',
      message: 'Select a Provisioning Profile:',
      choices,
      pageSize: Infinity
    };
    const {
      action
    } = await (0, _prompt().default)(question);

    if (action === 'GENERATE') {
      return new CreateProvisioningProfile({
        experienceName: this._experienceName,
        bundleIdentifier: this._bundleIdentifier,
        distCert: this._distCert,
        nonInteractive: this._nonInteractive
      });
    } else if (action === 'CHOOSE_EXISTING') {
      return new UseExistingProvisioningProfile({
        experienceName: this._experienceName,
        bundleIdentifier: this._bundleIdentifier,
        distCert: this._distCert
      });
    }

    throw new Error('unsupported action');
  }

}

exports.CreateOrReuseProvisioningProfile = CreateOrReuseProvisioningProfile;

async function selectProfileFromApple(appleCtx, bundleIdentifier) {
  const ppManager = new (_appleApi().ProvisioningProfileManager)(appleCtx);
  const profiles = await ppManager.list(bundleIdentifier);

  if (profiles.length === 0) {
    _log().default.warn(`There are no Provisioning Profiles available in your apple account for bundleIdentifier: ${bundleIdentifier}`);

    return null;
  }

  const question = {
    type: 'list',
    name: 'credentialsIndex',
    message: 'Select Provisioning Profile from the list.',
    choices: profiles.map((entry, index) => ({
      name: formatProvisioningProfileFromApple(entry),
      value: index
    }))
  };
  const {
    credentialsIndex
  } = await (0, _prompt().default)(question);
  return profiles[credentialsIndex];
}

async function selectProfileFromExpo(iosCredentials) {
  const profiles = iosCredentials.appCredentials.filter(({
    credentials
  }) => !!credentials.provisioningProfile && !!credentials.provisioningProfileId);

  if (profiles.length === 0) {
    _log().default.warn('There are no Provisioning Profiles available in your account');

    return null;
  }

  const getName = profile => {
    const id = _chalk().default.green(profile.credentials.provisioningProfileId || '-----');

    const teamId = profile.credentials.teamId || '------';
    return `Provisioning Profile (ID: ${id}, Team ID: ${teamId})`;
  };

  const question = {
    type: 'list',
    name: 'credentialsIndex',
    message: 'Select Provisioning Profile from the list.',
    choices: profiles.map((entry, index) => ({
      name: getName(entry),
      value: index
    }))
  };
  const {
    credentialsIndex
  } = await (0, _prompt().default)(question);
  return profiles[credentialsIndex];
}

async function generateProvisioningProfile(ctx, bundleIdentifier, distCert) {
  await ctx.ensureAppleCtx();
  const manager = new (_appleApi().ProvisioningProfileManager)(ctx.appleCtx);
  const type = ctx.appleCtx.team.inHouse ? 'Enterprise ' : 'AppStore';
  const profileName = `*[expo] ${bundleIdentifier} ${type} ${new Date().toISOString()}`; // Apple drops [ if its the first char (!!)

  return await manager.create(bundleIdentifier, distCert, profileName);
} // Best effort validation without Apple credentials


async function validateProfileWithoutApple(provisioningProfile, distCert, bundleIdentifier) {
  const spinner = (0, _ora().default)(`Performing best effort validation of Provisioning Profile...\n`).start();
  const base64EncodedProfile = provisioningProfile.provisioningProfile;

  if (!base64EncodedProfile) {
    spinner.fail('No profile on file');
    return false;
  }

  const buffer = Buffer.from(base64EncodedProfile, 'base64');
  const profile = buffer.toString('utf-8');

  const profilePlist = _plist().default.parse(profile);

  try {
    const distCertFingerprint = await _xdl().PKCS12Utils.getP12CertFingerprint(distCert.certP12, distCert.certPassword);

    _xdl().IosCodeSigning.validateProvisioningProfile(profilePlist, {
      distCertFingerprint,
      bundleIdentifier
    });
  } catch (e) {
    spinner.fail(`Provisioning profile is invalid: ${e.toString()}`);
    return false;
  }

  const isExpired = new Date(profilePlist['ExpirationDate']) <= new Date();

  if (isExpired) {
    spinner.fail('Provisioning profile is expired');
    return false;
  }

  spinner.succeed('Successfully performed best effort validation of Provisioning Profile.');
  return true;
}

async function getAppleInfo(appleCtx, bundleIdentifier, profile) {
  if (!profile.provisioningProfileId) {
    (0, _log().default)(_chalk().default.yellow('Provisioning Profile: cannot look up profile on Apple Servers - there is no id'));
    return null;
  }

  const spinner = (0, _ora().default)(`Getting Provisioning Profile info from Apple's Servers...\n`).start();
  const ppManager = new (_appleApi().ProvisioningProfileManager)(appleCtx);
  const profilesFromApple = await ppManager.list(bundleIdentifier);
  const configuredProfileFromApple = profilesFromApple.find(appleProfile => appleProfile.provisioningProfileId === profile.provisioningProfileId);

  if (!configuredProfileFromApple) {
    spinner.fail(`Provisioning Profile: ${profile.provisioningProfileId} does not exist on Apple Servers`);
    return null;
  }

  spinner.succeed(`Successfully fetched Provisioning Profile ${profile.provisioningProfileId} from Apple Servers`);
  return configuredProfileFromApple;
}

async function configureAndUpdateProvisioningProfile(ctx, experienceName, bundleIdentifier, distCert, profileFromApple) {
  // configure profile on Apple's Server to use our distCert
  const ppManager = new (_appleApi().ProvisioningProfileManager)(ctx.appleCtx);
  const updatedProfile = await ppManager.useExisting(bundleIdentifier, profileFromApple, distCert);
  (0, _log().default)(_chalk().default.green(`Successfully configured Provisioning Profile ${profileFromApple.provisioningProfileId} on Apple Servers with Distribution Certificate ${distCert.certId || ''}`)); // Update profile on expo servers

  await ctx.ios.updateProvisioningProfile(experienceName, bundleIdentifier, updatedProfile, ctx.appleCtx.team);
  (0, _log().default)(_chalk().default.green(`Successfully assigned Provisioning Profile to ${experienceName} (${bundleIdentifier})`));
}

function formatProvisioningProfileFromApple(appleInfo) {
  var _appleInfo$name;

  const {
    expires,
    provisioningProfileId
  } = appleInfo;
  const id = provisioningProfileId !== null && provisioningProfileId !== void 0 ? provisioningProfileId : '-----';
  const name = (_appleInfo$name = appleInfo.name) !== null && _appleInfo$name !== void 0 ? _appleInfo$name : '-----';
  const expireString = expires ? new Date(expires * 1000).toDateString() : 'unknown';

  const details = _chalk().default.green(`\n    Name: ${name}\n    Expiry: ${expireString}`);

  return `Provisioning Profile - ID: ${id}${details}`;
}

async function getProvisioningProfileFromParams(builderOptions) {
  const {
    provisioningProfilePath,
    teamId
  } = builderOptions; // none of the provisioningProfile params were set, assume user has no intention of passing it in

  if (!provisioningProfilePath && !teamId) {
    return null;
  } // partial provisioningProfile params were set, assume user has intention of passing it in


  if (!(provisioningProfilePath && teamId)) {
    throw new Error('In order to provide a Provisioning Profile through the CLI parameters, you have to pass --provisioning-profile-path and --team-id parameters.');
  }

  return {
    provisioningProfile: await _fsExtra().default.readFile(provisioningProfilePath, 'base64')
  };
}

async function useProvisioningProfileFromParams(ctx, appCredentials, teamId, provisioningProfile, distCert) {
  const {
    experienceName,
    bundleIdentifier
  } = appCredentials;
  const isValid = await validateProfileWithoutApple(provisioningProfile, distCert, appCredentials.bundleIdentifier);

  if (!isValid) {
    throw new Error('Uploaded invalid Provisioning Profile');
  }

  return await ctx.ios.updateProvisioningProfile(experienceName, bundleIdentifier, provisioningProfile, {
    id: teamId
  });
}
//# sourceMappingURL=IosProvisioningProfile.js.map