"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __importDefault(require("crypto"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const turtle_spawn_1 = __importDefault(require("@expo/turtle-spawn"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const isError_1 = __importDefault(require("lodash/isError"));
const plist_1 = __importDefault(require("plist"));
const v4_1 = __importDefault(require("uuid/v4"));
const PROVISIONING_PROFILES_DIRECTORY = path_1.default.join(os_1.default.homedir(), 'Library/MobileDevice/Provisioning Profiles');
class ProvisioningProfile {
    constructor(logger, profile) {
        this.logger = logger;
        this.profile = profile;
        this.profilePath = path_1.default.join(PROVISIONING_PROFILES_DIRECTORY, `${v4_1.default()}.mobileprovision`);
    }
    get data() {
        if (!this.profileData) {
            throw new Error('You must init the profile first!');
        }
        else {
            return this.profileData;
        }
    }
    async init() {
        this.logger.debug(`Making sure ${PROVISIONING_PROFILES_DIRECTORY} exits`);
        await fs_extra_1.default.ensureDir(PROVISIONING_PROFILES_DIRECTORY);
        this.logger.debug(`Writing provisioning profile to ${this.profilePath}`);
        await fs_extra_1.default.writeFile(this.profilePath, this.profile);
        this.logger.debug('Loading provisioning profile');
        await this.load();
    }
    async destroy() {
        if (!this.profilePath) {
            this.logger.warn('There is nothing to destroy, a provisioning profile hasn\'t been created yet.');
            return;
        }
        this.logger.info('Removing provisioning profile');
        await fs_extra_1.default.remove(this.profilePath);
    }
    verifyCertificate(fingerprint) {
        const devCertFingerprint = this.genDerCertFingerprint();
        if (devCertFingerprint !== fingerprint) {
            throw new Error(`Provisioning profile and distribution certificate don't match.
Profile's certificate fingerprint = ${devCertFingerprint}, distribution certificate fingerprint = ${fingerprint}`);
        }
    }
    async load() {
        let result;
        try {
            result = await turtle_spawn_1.default('security', ['cms', '-D', '-i', this.profilePath], { stdio: 'pipe' });
        }
        catch (err) {
            throw new Error(err.stderr.trim());
        }
        const { output } = result;
        const plistRaw = output.join('');
        const plistData = plist_1.default.parse(plistRaw);
        if (isError_1.default(plistData)) {
            throw new Error(`Error when parsing plist: ${plistData.message}`);
        }
        const applicationIdentifier = plistData.Entitlements['application-identifier'];
        const bundleIdentifier = applicationIdentifier.replace(/^.+?\./, '');
        this.profileData = {
            bundleIdentifier,
            teamId: plistData.TeamIdentifier[0],
            uuid: plistData.UUID,
            developerCertificate: Buffer.from(plistData.DeveloperCertificates[0], 'base64'),
        };
    }
    genDerCertFingerprint() {
        return crypto_1.default
            .createHash('sha1')
            .update(this.data.developerCertificate)
            .digest('hex')
            .toUpperCase();
    }
}
exports.default = ProvisioningProfile;
//# sourceMappingURL=provisioningProfile.js.map