"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const fastlane_1 = __importDefault(require("@expo/fastlane"));
const turtle_spawn_1 = __importDefault(require("@expo/turtle-spawn"));
const v4_1 = __importDefault(require("uuid/v4"));
class Keychain {
    constructor(logger) {
        this.created = false;
        this.logger = logger;
        this.keychainPath = path_1.default.join(os_1.default.tmpdir(), `turtle-v2-${v4_1.default()}.keychain`);
        this.keychainPassword = v4_1.default();
    }
    get data() {
        return {
            path: this.keychainPath,
            password: this.keychainPassword,
        };
    }
    async create() {
        this.logger.debug(`Creating keychain - ${this.keychainPath}`);
        await fastlane_1.default([
            'run',
            'create_keychain',
            `path:${this.keychainPath}`,
            `password:${this.keychainPassword}`,
            'unlock:true',
            'timeout:360000',
        ]);
        this.created = true;
    }
    async importCertificate(certPath, certPassword) {
        if (!this.created) {
            throw new Error('You must create a keychain first.');
        }
        this.logger.debug(`Importing certificate ${certPath} into keychain ${this.keychainPath}`);
        await fastlane_1.default([
            'run',
            'import_certificate',
            `certificate_path:${certPath}`,
            `certificate_password:${certPassword}`,
            `keychain_path:${this.keychainPath}`,
            `keychain_password:${this.keychainPassword}`,
        ]);
    }
    async ensureCertificateImported(teamId, fingerprint) {
        const identities = await this.findIdentitiesByTeamId(teamId);
        if (!identities.includes(fingerprint)) {
            throw new Error(`Distribution certificate with fingerprint ${fingerprint} hasn't been imported successfully`);
        }
    }
    async destroy(keychainPath) {
        if (!keychainPath && !this.created) {
            this.logger.warn('There is nothing to destroy, a keychain hasn\'t been created yet.');
            return;
        }
        const keychainToDeletePath = keychainPath || this.keychainPath;
        this.logger.info(`Destroying keychain - ${keychainToDeletePath}`);
        await fastlane_1.default([
            'run',
            'delete_keychain',
            `keychain_path:${keychainToDeletePath}`,
        ]);
    }
    async cleanUpKeychains() {
        const { stdout } = await turtle_spawn_1.default('security', ['list-keychains'], { stdio: 'pipe' });
        const keychainList = (/"(.*)"/g.exec(stdout) || []).map((i) => i.slice(1, i.length - 1));
        const turtleKeychainList = keychainList.filter((keychain) => /turtle-v2-[\w-]+\.keychain$/.exec(keychain));
        for (const turtleKeychainPath of turtleKeychainList) {
            await this.destroy(turtleKeychainPath);
        }
    }
    async findIdentitiesByTeamId(teamId) {
        const { output } = await turtle_spawn_1.default('security', ['find-identity', '-v', '-s', `(${teamId})`, this.keychainPath], { stdio: 'pipe' });
        return output.join('');
    }
}
exports.default = Keychain;
//# sourceMappingURL=keychain.js.map