"use strict";
// @flow
// adapted from 'graphql-subscriptions' package
Object.defineProperty(exports, "__esModule", { value: true });
const iterall_1 = require("iterall");
function eventEmitterToAsyncIterator(eventEmitter, eventsNames) {
    const pullQueue = [];
    const pushQueue = [];
    const eventsArray = typeof eventsNames === 'string' ? [eventsNames] : eventsNames;
    let listening = true;
    const pushValue = event => {
        if (pullQueue.length !== 0) {
            // @ts-ignore
            pullQueue.shift()({ value: event, done: false });
        }
        else {
            pushQueue.push(event);
        }
    };
    const pullValue = () => {
        return new Promise(resolve => {
            if (pushQueue.length !== 0) {
                resolve({ value: pushQueue.shift(), done: false });
            }
            else {
                pullQueue.push(resolve);
            }
        });
    };
    const emptyQueue = () => {
        if (listening) {
            listening = false;
            removeEventListeners();
            pullQueue.forEach(resolve => resolve({ value: undefined, done: true }));
            pullQueue.length = 0;
            pushQueue.length = 0;
        }
    };
    const listeners = [];
    const addEventListeners = () => {
        for (const eventName of eventsArray) {
            const listener = [
                eventName,
                event => pushValue({
                    eventName,
                    event,
                }),
            ];
            listeners.push(listener);
            // @ts-ignore
            eventEmitter.addListener(eventName, listener[1]);
        }
    };
    const removeEventListeners = () => {
        for (const [eventName, listener] of listeners) {
            eventEmitter.removeListener(eventName, listener);
        }
    };
    addEventListeners();
    return {
        next() {
            // @ts-ignore
            return listening ? pullValue() : this.return();
        },
        return() {
            emptyQueue();
            return Promise.resolve({ value: undefined, done: true });
        },
        throw(error) {
            emptyQueue();
            return Promise.reject(error);
        },
        [iterall_1.$$asyncIterator]() {
            return this;
        },
    };
}
exports.default = eventEmitterToAsyncIterator;
//# sourceMappingURL=eventEmitterToAsyncIterator.js.map