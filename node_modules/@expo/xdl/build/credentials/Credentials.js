"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCredentialMetadataAsync = getCredentialMetadataAsync;
exports.credentialsExistForPlatformAsync = credentialsExistForPlatformAsync;
exports.getEncryptedCredentialsForPlatformAsync = getEncryptedCredentialsForPlatformAsync;
exports.getCredentialsForPlatform = getCredentialsForPlatform;
exports.updateCredentialsForPlatform = updateCredentialsForPlatform;
exports.removeCredentialsForPlatform = removeCredentialsForPlatform;
exports.Ios = void 0;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _xdl() {
  const data = require("../xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _Api() {
  const data = _interopRequireDefault(require("../Api"));

  _Api = function () {
    return data;
  };

  return data;
}

function _User() {
  const data = _interopRequireDefault(require("../User"));

  _User = function () {
    return data;
  };

  return data;
}

function Ios() {
  const data = _interopRequireWildcard(require("./IosCredentials"));

  Ios = function () {
    return data;
  };

  return data;
}

Object.defineProperty(exports, "Ios", {
  enumerable: true,
  get: function () {
    return Ios();
  }
});

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function getCredentialMetadataAsync(projectRoot, platform) {
  var _exp$ios;

  const {
    exp
  } = (0, _config().getConfig)(projectRoot, {
    skipSDKVersionRequirement: true
  });
  const user = await _User().default.ensureLoggedInAsync();
  let {
    username
  } = user;

  if (exp.owner) {
    username = exp.owner;
  }

  const bundleIdentifier = platform === 'ios' ? (_exp$ios = exp.ios) === null || _exp$ios === void 0 ? void 0 : _exp$ios.bundleIdentifier : undefined;
  return {
    username,
    experienceName: `@${username}/${exp.slug}`,
    bundleIdentifier,
    platform
  };
}

async function credentialsExistForPlatformAsync(metadata) {
  const credentials = await fetchCredentials(metadata, false);
  return !!credentials;
}

async function getEncryptedCredentialsForPlatformAsync(metadata) {
  return fetchCredentials(metadata, false);
}

async function getCredentialsForPlatform(metadata) {
  return fetchCredentials(metadata, true);
}

async function fetchCredentials({
  username,
  experienceName,
  bundleIdentifier,
  platform
}, decrypt) {
  // this doesn't hit our mac rpc channel, so it needs significantly less debugging
  let credentials;

  if (process.env.EXPO_NEXT_API === 'true') {
    const user = await _User().default.ensureLoggedInAsync();

    const api = _xdl().ApiV2.clientForUser(user);

    if (platform === 'android') {
      credentials = await api.getAsync(`credentials/android/keystore/${experienceName}`);

      if (credentials['keystore']) {
        credentials['keystore']['keystoreAlias'] = credentials['keystore']['keyAlias'];
        delete credentials['keystore']['keyAlias'];
      } else {
        credentials = null;
      }
    } else if (platform === 'ios') {
      const record = await api.getAsync(`credentials/ios/${experienceName}/${encodeURI(bundleIdentifier !== null && bundleIdentifier !== void 0 ? bundleIdentifier : '')}`);

      if (record) {
        credentials = { ...record.pushCredentials,
          ...record.distCredentials,
          ...record.credentials
        };
      } else {
        credentials = {};
      }
    }
  } else {
    const response = await _Api().default.callMethodAsync('getCredentials', [], 'post', {
      username,
      experienceName,
      bundleIdentifier,
      platform,
      decrypt
    });

    if (response.err) {
      throw new Error('Error fetching credentials.');
    }

    credentials = response.credentials;
  }

  return credentials;
}

async function updateCredentialsForPlatform(platform, newCredentials, userCredentialsIds, metadata) {
  if (process.env.EXPO_NEXT_API === 'true') {
    const {
      experienceName
    } = metadata;
    const user = await _User().default.ensureLoggedInAsync();

    const api = _xdl().ApiV2.clientForUser(user);

    const result = await api.putAsync(`credentials/android/keystore/${experienceName}`, {
      keystore: newCredentials
    });

    if (result.errors) {
      throw new Error(`Error updating credentials: ${JSON.stringify(result.errors)}`);
    }
  } else {
    const {
      err,
      credentials
    } = await _Api().default.callMethodAsync('updateCredentials', [], 'post', {
      credentials: newCredentials,
      userCredentialsIds,
      platform,
      ...metadata
    });

    if (err || !credentials) {
      throw new Error('Error updating credentials.');
    }
  }
}

async function removeCredentialsForPlatform(platform, // this is only used for android credential management now.
metadata) {
  // doesn't go through mac rpc, no request id needed
  if (process.env.EXPO_NEXT_API === 'true') {
    const user = await _User().default.ensureLoggedInAsync();

    const api = _xdl().ApiV2.clientForUser(user);

    await api.deleteAsync(`credentials/android/keystore/${metadata.experienceName}`);
  } else {
    const {
      err
    } = await _Api().default.callMethodAsync('deleteCredentials', [], 'post', {
      platform,
      ...metadata
    });

    if (err) {
      throw new Error('Error deleting credentials.');
    }
  }
}
//# sourceMappingURL=../__sourcemaps__/credentials/Credentials.js.map
