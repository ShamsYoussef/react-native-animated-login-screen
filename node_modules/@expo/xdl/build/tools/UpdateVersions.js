"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateSdkVersionsAsync = updateSdkVersionsAsync;
exports.updateIOSSimulatorBuild = updateIOSSimulatorBuild;
exports.updateAndroidApk = updateAndroidApk;

function _fs() {
  const data = _interopRequireDefault(require("fs"));

  _fs = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _spawnAsync() {
  const data = _interopRequireDefault(require("@expo/spawn-async"));

  _spawnAsync = function () {
    return data;
  };

  return data;
}

function Versions() {
  const data = _interopRequireWildcard(require("../Versions"));

  Versions = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function updateSdkVersionsAsync(sdkVersion, reactNativeTag, facebookRNVersion, facebookReactVersion) {
  let versions = await Versions().versionsAsync();
  versions.sdkVersions[sdkVersion] = { ...versions.sdkVersions[sdkVersion],
    expoReactNativeTag: reactNativeTag,
    facebookReactNativeVersion: facebookRNVersion,
    facebookReactVersion
  };
  await Versions().setVersionsAsync(versions);
}

async function updateIOSSimulatorBuild(s3Client, pathToApp, appVersion, sdkVersion) {
  let tempAppPath = _path().default.join(process.cwd(), 'temp-app.tar.gz');

  await (0, _spawnAsync().default)('tar', ['-zcvf', tempAppPath, '-C', pathToApp, '.'], {
    cwd: process.cwd(),
    stdio: ['ignore', 'ignore', 'inherit'] // only stderr

  });

  let file = _fs().default.createReadStream(tempAppPath);

  console.log('Uploading...');
  await s3Client.putObject({
    Bucket: 'exp-ios-simulator-apps',
    Key: `Exponent-${appVersion}.tar.gz`,
    Body: file,
    ACL: 'public-read'
  }).promise();
  await (0, _spawnAsync().default)('rm', [tempAppPath]);
  console.log('Adding to server config...');
  const clientUrl = `https://dpq5q02fu5f55.cloudfront.net/Exponent-${appVersion}.tar.gz`;
  await updateClientUrlAndVersionAsync(sdkVersion, 'ios', clientUrl, appVersion);
}

async function updateAndroidApk(s3Client, pathToApp, appVersion, sdkVersion) {
  let file = _fs().default.createReadStream(pathToApp);

  console.log('Uploading...');
  await s3Client.putObject({
    Bucket: 'exp-android-apks',
    Key: `Exponent-${appVersion}.apk`,
    Body: file,
    ACL: 'public-read'
  }).promise();
  console.log('Adding to server config...');
  const clientUrl = `https://d1ahtucjixef4r.cloudfront.net/Exponent-${appVersion}.apk`;
  await updateClientUrlAndVersionAsync(sdkVersion, 'android', clientUrl, appVersion);
}

async function updateClientUrlAndVersionAsync(sdkVersion, platform, clientUrl, appVersion) {
  // Unfortunately it needs to be of `any` type to be able to change dynamic keys in the object.
  const versions = await Versions().versionsAsync(); // Create new SDK version config if it's not there yet.

  if (sdkVersion && !versions.sdkVersions[sdkVersion]) {
    versions.sdkVersions[sdkVersion] = {};
  } // For compatibility reasons we have to maintain that global config, but only when we're updating the most recent SDK.


  if (!sdkVersion || Object.keys(versions.sdkVersions).sort(_semver().default.rcompare)[0] === sdkVersion) {
    versions[`${platform}Version`] = appVersion;
    versions[`${platform}Url`] = clientUrl;
  } // Update SDK version config.


  if (sdkVersion) {
    const sdkVersionConfig = versions.sdkVersions[sdkVersion];
    sdkVersionConfig[`${platform}ClientUrl`] = clientUrl;
    sdkVersionConfig[`${platform}ClientVersion`] = appVersion;
  }

  await Versions().setVersionsAsync(versions);
}
//# sourceMappingURL=../__sourcemaps__/tools/UpdateVersions.js.map
