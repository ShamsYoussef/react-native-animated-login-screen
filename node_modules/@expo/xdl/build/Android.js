"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPlatformSupported = isPlatformSupported;
exports.getAdbOutputAsync = getAdbOutputAsync;
exports.downloadApkAsync = downloadApkAsync;
exports.installExpoAsync = installExpoAsync;
exports.uninstallExpoAsync = uninstallExpoAsync;
exports.upgradeExpoAsync = upgradeExpoAsync;
exports.assertDeviceReadyAsync = assertDeviceReadyAsync;
exports.openProjectAsync = openProjectAsync;
exports.openWebProjectAsync = openWebProjectAsync;
exports.startAdbReverseAsync = startAdbReverseAsync;
exports.stopAdbReverseAsync = stopAdbReverseAsync;
exports.checkSplashScreenImages = checkSplashScreenImages;
exports.maybeStopAdbDaemonAsync = maybeStopAdbDaemonAsync;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _spawnAsync() {
  const data = _interopRequireDefault(require("@expo/spawn-async"));

  _spawnAsync = function () {
    return data;
  };

  return data;
}

function _child_process() {
  const data = _interopRequireDefault(require("child_process"));

  _child_process = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _progress() {
  const data = _interopRequireDefault(require("progress"));

  _progress = function () {
    return data;
  };

  return data;
}

function Analytics() {
  const data = _interopRequireWildcard(require("./Analytics"));

  Analytics = function () {
    return data;
  };

  return data;
}

function _Api() {
  const data = _interopRequireDefault(require("./Api"));

  _Api = function () {
    return data;
  };

  return data;
}

function Binaries() {
  const data = _interopRequireWildcard(require("./Binaries"));

  Binaries = function () {
    return data;
  };

  return data;
}

function _Logger() {
  const data = _interopRequireDefault(require("./Logger"));

  _Logger = function () {
    return data;
  };

  return data;
}

function _NotificationCode() {
  const data = _interopRequireDefault(require("./NotificationCode"));

  _NotificationCode = function () {
    return data;
  };

  return data;
}

function ProjectSettings() {
  const data = _interopRequireWildcard(require("./ProjectSettings"));

  ProjectSettings = function () {
    return data;
  };

  return data;
}

function _ImageUtils() {
  const data = require("./tools/ImageUtils");

  _ImageUtils = function () {
    return data;
  };

  return data;
}

function UrlUtils() {
  const data = _interopRequireWildcard(require("./UrlUtils"));

  UrlUtils = function () {
    return data;
  };

  return data;
}

function _UserSettings() {
  const data = _interopRequireDefault(require("./UserSettings"));

  _UserSettings = function () {
    return data;
  };

  return data;
}

function Versions() {
  const data = _interopRequireWildcard(require("./Versions"));

  Versions = function () {
    return data;
  };

  return data;
}

function _Webpack() {
  const data = require("./Webpack");

  _Webpack = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let _lastUrl = null;
const BEGINNING_OF_ADB_ERROR_MESSAGE = 'error: ';
const CANT_START_ACTIVITY_ERROR = 'Activity not started, unable to resolve Intent';
const INSTALL_WARNING_TIMEOUT = 60 * 1000;
const EMULATOR_MAX_WAIT_TIMEOUT = 30 * 1000;

function whichEmulator() {
  if (process.env.ANDROID_HOME) {
    return `${process.env.ANDROID_HOME}/emulator/emulator`;
  }

  return 'emulator';
}

function whichADB() {
  if (process.env.ANDROID_HOME) {
    return `${process.env.ANDROID_HOME}/platform-tools/adb`;
  }

  return 'adb';
}
/**
 * Returns a list of emulator names.
 */


async function getEmulatorsAsync() {
  try {
    const {
      stdout
    } = await (0, _spawnAsync().default)(whichEmulator(), ['-list-avds']);
    return stdout.split('\n').filter(Boolean);
  } catch (_unused) {
    return [];
  }
}

async function maybeStartEmulatorAsync(name) {
  _Logger().default.global.info(`\u203A Attempting to open emulator named: ${name}`); // Start a process to open an emulator


  const emulatorProcess = _child_process().default.spawn(whichEmulator(), [`@${name}`], {
    stdio: 'ignore',
    detached: true
  });

  emulatorProcess.unref();
  return new Promise((resolve, reject) => {
    const waitTimer = setInterval(async () => {
      if (await _isDeviceAttachedAsync()) {
        stopWaiting();
        resolve();
      }
    }, 1000); // Reject command after timeout

    const maxWait = setTimeout(() => {
      const manualCommand = `${whichEmulator()} @${name}`;
      stopWaitingAndReject(`It took too long to start the Android emulator: ${name}. You can try starting the emulator manually from the terminal with: ${manualCommand}`);
    }, EMULATOR_MAX_WAIT_TIMEOUT);

    const stopWaiting = () => {
      clearTimeout(maxWait);
      clearInterval(waitTimer);
    };

    const stopWaitingAndReject = message => {
      stopWaiting();
      reject(new Error(message));
      clearInterval(waitTimer);
    };

    emulatorProcess.on('error', ({
      message
    }) => stopWaitingAndReject(message));
    emulatorProcess.on('exit', () => {
      const manualCommand = `${whichEmulator()} @${name}`;
      stopWaitingAndReject(`The emulator (${name}) quit before it finished opening. You can try starting the emulator manually from the terminal with: ${manualCommand}`);
    });
  });
}

async function maybeStartAnyEmulatorAsync() {
  const emulators = await getEmulatorsAsync();

  if (emulators.length > 0) {
    await maybeStartEmulatorAsync(emulators[0]);
    return true;
  }

  return false;
}

function isPlatformSupported() {
  return process.platform === 'darwin' || process.platform === 'win32' || process.platform === 'linux';
}

async function getAdbOutputAsync(args) {
  await Binaries().addToPathAsync('adb');
  const adb = whichADB();

  try {
    let result = await (0, _spawnAsync().default)(adb, args);
    return result.stdout;
  } catch (e) {
    let errorMessage = (e.stderr || e.stdout || e.message).trim();

    if (errorMessage.startsWith(BEGINNING_OF_ADB_ERROR_MESSAGE)) {
      errorMessage = errorMessage.substring(BEGINNING_OF_ADB_ERROR_MESSAGE.length);
    }

    throw new Error(errorMessage);
  }
} // Device attached


async function _isDeviceAttachedAsync() {
  let output = await getAdbOutputAsync(['devices']);
  const devices = output.trim().split(/\r?\n/).reduce((previous, line) => {
    const [name, type] = line.split(/[ ,\t]+/).filter(Boolean);
    return type === 'device' ? previous.concat(name) : previous;
  }, []);
  return devices.length > 0;
}

async function _isDeviceAuthorizedAsync() {
  let devices = await getAdbOutputAsync(['devices']);
  let lines = devices.trim().split(/\r?\n/);
  lines.shift();
  let listOfDevicesWithoutFirstLine = lines.join('\n'); // result looks like "072c4cf200e333c7  device" when authorized
  // and "072c4cf200e333c7  unauthorized" when not.

  return listOfDevicesWithoutFirstLine.includes('device');
} // Expo installed


async function _isExpoInstalledAsync() {
  let packages = await getAdbOutputAsync(['shell', 'pm', 'list', 'packages', '-f']);
  let lines = packages.split(/\r?\n/);

  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];

    if (line.includes('host.exp.exponent.test')) {
      continue;
    }

    if (line.includes('host.exp.exponent')) {
      return true;
    }
  }

  return false;
}

async function _expoVersionAsync() {
  let info = await getAdbOutputAsync(['shell', 'dumpsys', 'package', 'host.exp.exponent']);
  let regex = /versionName=([0-9.]+)/;
  let regexMatch = regex.exec(info);

  if (!regexMatch || regexMatch.length < 2) {
    return null;
  }

  return regexMatch[1];
} // NOTE(brentvatne): Temporarily remove this. We should take care of installing
// automatically, not just warn.


async function _checkExpoUpToDateAsync() {// let versions = await Versions.versionsAsync();
  // let installedVersion = await _expoVersionAsync();
  // if (!installedVersion || semver.lt(installedVersion, versions.androidVersion)) {
  //   Logger.notifications.warn(
  //     { code: NotificationCode.OLD_ANDROID_APP_VERSION },
  //     'This version of the Expo app is out of date. Uninstall the app and run again to upgrade.'
  //   );
  // }
}

function _apkCacheDirectory() {
  let dotExpoHomeDirectory = _UserSettings().default.dotExpoHomeDirectory();

  let dir = _path().default.join(dotExpoHomeDirectory, 'android-apk-cache');

  _fsExtra().default.mkdirpSync(dir);

  return dir;
}

async function downloadApkAsync(url, downloadProgressCallback) {
  let versions = await Versions().versionsAsync();

  let apkPath = _path().default.join(_apkCacheDirectory(), `Exponent-${versions.androidVersion}.apk`);

  if (await _fsExtra().default.pathExists(apkPath)) {
    return apkPath;
  }

  await _Api().default.downloadAsync(url || versions.androidUrl, _path().default.join(_apkCacheDirectory(), `Exponent-${versions.androidVersion}.apk`), undefined, downloadProgressCallback);
  return apkPath;
}

async function installExpoAsync(url) {
  const bar = new (_progress().default)('Downloading the Expo client app [:bar] :percent :etas', {
    total: 100,
    width: 40
  });
  let warningTimer;

  const setWarningTimer = () => {
    if (warningTimer) {
      clearTimeout(warningTimer);
    }

    return setTimeout(() => {
      _Logger().default.global.info('');

      _Logger().default.global.info('This download is taking longer than expected. You can also try downloading the clients from the website at https://expo.io/tools');
    }, INSTALL_WARNING_TIMEOUT);
  };

  _Logger().default.notifications.info({
    code: _NotificationCode().default.START_LOADING
  });

  warningTimer = setWarningTimer();
  let path = await downloadApkAsync(url, progress => bar.tick(1, progress));

  _Logger().default.notifications.info({
    code: _NotificationCode().default.STOP_LOADING
  });

  _Logger().default.global.info(`Installing Expo on device`);

  _Logger().default.notifications.info({
    code: _NotificationCode().default.START_LOADING
  });

  warningTimer = setWarningTimer();
  let result = await getAdbOutputAsync(['install', path]);

  _Logger().default.notifications.info({
    code: _NotificationCode().default.STOP_LOADING
  });

  clearTimeout(warningTimer);
  return result;
}

async function uninstallExpoAsync() {
  _Logger().default.global.info('Uninstalling Expo from Android device.'); // we need to check if its installed, else we might bump into "Failure [DELETE_FAILED_INTERNAL_ERROR]"


  const isInstalled = await _isExpoInstalledAsync();

  if (!isInstalled) {
    return;
  }

  try {
    return await getAdbOutputAsync(['uninstall', 'host.exp.exponent']);
  } catch (e) {
    _Logger().default.global.error('Could not uninstall Expo client from your device, please uninstall Expo client manually and try again.');

    throw e;
  }
}

async function upgradeExpoAsync(url) {
  try {
    await attemptToStartEmulatorOrAssertAsync();
    await uninstallExpoAsync();
    await installExpoAsync(url);

    if (_lastUrl) {
      _Logger().default.global.info(`Opening ${_lastUrl} in Expo.`);

      await getAdbOutputAsync(['shell', 'am', 'start', '-a', 'android.intent.action.VIEW', '-d', _lastUrl]);
      _lastUrl = null;
    }

    return true;
  } catch (e) {
    _Logger().default.global.error(e.message);

    return false;
  }
} // Open Url


async function assertDeviceReadyAsync() {
  const genymotionMessage = `https://developer.android.com/studio/run/device.html#developer-device-options. If you are using Genymotion go to Settings -> ADB, select "Use custom Android SDK tools", and point it at your Android SDK directory.`;

  if (!(await _isDeviceAuthorizedAsync())) {
    throw new Error(`This computer is not authorized to debug the device. Please follow the instructions here to enable USB debugging:\n${genymotionMessage}`);
  }
}

async function _openUrlAsync(url) {
  // NOTE(brentvatne): temporary workaround! launch expo client first, then
  // launch the project!
  // https://github.com/expo/expo/issues/7772
  // adb shell monkey -p host.exp.exponent -c android.intent.category.LAUNCHER 1
  let openClient = await getAdbOutputAsync(['shell', 'monkey', '-p', 'host.exp.exponent', '-c', 'android.intent.category.LAUNCHER', '1']);

  if (openClient.includes(CANT_START_ACTIVITY_ERROR)) {
    throw new Error(openClient.substring(openClient.indexOf('Error: ')));
  }

  let openProject = await getAdbOutputAsync(['shell', 'am', 'start', '-a', 'android.intent.action.VIEW', '-d', url]);

  if (openProject.includes(CANT_START_ACTIVITY_ERROR)) {
    throw new Error(openProject.substring(openProject.indexOf('Error: ')));
  }

  return openProject;
}

async function attemptToStartEmulatorOrAssertAsync() {
  if (!(await _isDeviceAttachedAsync())) {
    // If no devices or emulators are attached we should attempt to open one.
    if (!(await maybeStartAnyEmulatorAsync())) {
      const genymotionMessage = `https://developer.android.com/studio/run/device.html#developer-device-options. If you are using Genymotion go to Settings -> ADB, select "Use custom Android SDK tools", and point it at your Android SDK directory.`;
      throw new Error(`No Android connected device found, and no emulators could be started automatically.\nPlease connect a device or create an emulator (https://docs.expo.io/workflow/android-studio-emulator).\nThen follow the instructions here to enable USB debugging:\n${genymotionMessage}`);
    }
  }

  await assertDeviceReadyAsync();
}

async function openUrlAsync(url, isDetached = false) {
  try {
    await attemptToStartEmulatorOrAssertAsync();
    let installedExpo = false;

    if (!isDetached && !(await _isExpoInstalledAsync())) {
      await installExpoAsync();
      installedExpo = true;
    }

    if (!isDetached) {
      _lastUrl = url;

      _checkExpoUpToDateAsync(); // let this run in background

    }

    _Logger().default.global.info(`Opening on Android device`);

    try {
      await _openUrlAsync(url);
    } catch (e) {
      if (isDetached) {
        e.message = `Error running app. Have you installed the app already using Android Studio? Since you are detached you must build manually. ${e.message}`;
      } else {
        e.message = `Error running app. ${e.message}`;
      }

      throw e;
    }

    Analytics().logEvent('Open Url on Device', {
      platform: 'android',
      installedExpo
    });
  } catch (e) {
    e.message = `Error running adb: ${e.message}`;
    throw e;
  }
}

async function openProjectAsync(projectRoot) {
  try {
    await startAdbReverseAsync(projectRoot);
    let projectUrl = await UrlUtils().constructManifestUrlAsync(projectRoot);
    const {
      exp
    } = (0, _config().getConfig)(projectRoot, {
      skipSDKVersionRequirement: true
    });
    await openUrlAsync(projectUrl, !!exp.isDetached);
    return {
      success: true,
      url: projectUrl
    };
  } catch (e) {
    _Logger().default.global.error(`Couldn't start project on Android: ${e.message}`);

    return {
      success: false,
      error: e
    };
  }
}

async function openWebProjectAsync(projectRoot) {
  try {
    await startAdbReverseAsync(projectRoot);
    const projectUrl = await (0, _Webpack().getUrlAsync)(projectRoot);

    if (projectUrl === null) {
      return {
        success: false,
        error: `The web project has not been started yet`
      };
    }

    await openUrlAsync(projectUrl, true);
    return {
      success: true,
      url: projectUrl
    };
  } catch (e) {
    _Logger().default.global.error(`Couldn't open the web project on Android: ${e.message}`);

    return {
      success: false,
      error: e
    };
  }
} // Adb reverse


async function startAdbReverseAsync(projectRoot) {
  const packagerInfo = await ProjectSettings().readPackagerInfoAsync(projectRoot);
  const expRc = await (0, _config().readExpRcAsync)(projectRoot);
  const userDefinedAdbReversePorts = expRc.extraAdbReversePorts || [];
  let adbReversePorts = [packagerInfo.packagerPort, packagerInfo.expoServerPort, ...userDefinedAdbReversePorts];

  for (let port of adbReversePorts) {
    if (!(await adbReverse(port))) {
      return false;
    }
  }

  return true;
}

async function stopAdbReverseAsync(projectRoot) {
  const packagerInfo = await ProjectSettings().readPackagerInfoAsync(projectRoot);
  const expRc = await (0, _config().readExpRcAsync)(projectRoot);
  const userDefinedAdbReversePorts = expRc.extraAdbReversePorts || [];
  let adbReversePorts = [packagerInfo.packagerPort, packagerInfo.expoServerPort, ...userDefinedAdbReversePorts];

  for (let port of adbReversePorts) {
    await adbReverseRemove(port);
  }
}

async function adbReverse(port) {
  if (!(await _isDeviceAuthorizedAsync())) {
    return false;
  }

  try {
    await getAdbOutputAsync(['reverse', `tcp:${port}`, `tcp:${port}`]);
    return true;
  } catch (e) {
    _Logger().default.global.warn(`Couldn't adb reverse: ${e.message}`);

    return false;
  }
}

async function adbReverseRemove(port) {
  if (!(await _isDeviceAuthorizedAsync())) {
    return false;
  }

  try {
    await getAdbOutputAsync(['reverse', '--remove', `tcp:${port}`]);
    return true;
  } catch (e) {
    // Don't send this to warn because we call this preemptively sometimes
    _Logger().default.global.debug(`Couldn't adb reverse remove: ${e.message}`);

    return false;
  }
}

const splashScreenDPIConstraints = [{
  dpi: 'mdpi',
  sizeMultiplier: 1
}, {
  dpi: 'hdpi',
  sizeMultiplier: 1.5
}, {
  dpi: 'xhdpi',
  sizeMultiplier: 2
}, {
  dpi: 'xxhdpi',
  sizeMultiplier: 3
}, {
  dpi: 'xxxhdpi',
  sizeMultiplier: 4
}];
/**
 * Checks whether `resizeMode` is set to `native` and if `true` analyzes provided images for splashscreen
 * providing `Logger` feedback upon problems.
 * @param projectDir - directory of the expo project
 * @since SDK33
 */

async function checkSplashScreenImages(projectDir) {
  var _ref, _exp$android$splash$r, _exp$android, _exp$android$splash, _exp$splash, _exp$splash2, _exp$android2;

  const {
    exp
  } = (0, _config().getConfig)(projectDir); // return before SDK33

  if (!Versions().gteSdkVersion(exp, '33.0.0')) {
    return;
  }

  const splashScreenMode = (_ref = (_exp$android$splash$r = (_exp$android = exp.android) === null || _exp$android === void 0 ? void 0 : (_exp$android$splash = _exp$android.splash) === null || _exp$android$splash === void 0 ? void 0 : _exp$android$splash.resizeMode) !== null && _exp$android$splash$r !== void 0 ? _exp$android$splash$r : (_exp$splash = exp.splash) === null || _exp$splash === void 0 ? void 0 : _exp$splash.resizeMode) !== null && _ref !== void 0 ? _ref : 'contain'; // only mode `native` is handled by this check

  if (splashScreenMode === 'contain' || splashScreenMode === 'cover') {
    return;
  }

  const generalSplashImagePath = (_exp$splash2 = exp.splash) === null || _exp$splash2 === void 0 ? void 0 : _exp$splash2.image;

  if (!generalSplashImagePath) {
    _Logger().default.global.warn(`Couldn't read '${_chalk().default.italic('splash.image')}' from ${_chalk().default.italic('app.json')}. Provide asset that would serve as baseline splash image.`);

    return;
  }

  const generalSplashImage = await (0, _ImageUtils().getImageDimensionsAsync)(projectDir, generalSplashImagePath);

  if (!generalSplashImage) {
    _Logger().default.global.warn(`Couldn't read dimensions of provided splash image '${_chalk().default.italic(generalSplashImagePath)}'. Does the file exist?`);

    return;
  }

  const androidSplash = (_exp$android2 = exp.android) === null || _exp$android2 === void 0 ? void 0 : _exp$android2.splash;
  const androidSplashImages = [];

  for (const {
    dpi,
    sizeMultiplier
  } of splashScreenDPIConstraints) {
    const imageRelativePath = androidSplash === null || androidSplash === void 0 ? void 0 : androidSplash[dpi];

    if (imageRelativePath) {
      const splashImage = await (0, _ImageUtils().getImageDimensionsAsync)(projectDir, imageRelativePath);

      if (!splashImage) {
        _Logger().default.global.warn(`Couldn't read dimensions of provided splash image '${_chalk().default.italic(imageRelativePath)}'. Does the file exist?`);

        continue;
      }

      const {
        width,
        height
      } = splashImage;
      const expectedWidth = sizeMultiplier * generalSplashImage.width;
      const expectedHeight = sizeMultiplier * generalSplashImage.height;
      androidSplashImages.push({
        dpi,
        width,
        height,
        expectedWidth,
        expectedHeight,
        sizeMatches: width === expectedWidth && height === expectedHeight
      });
    }
  }

  if (androidSplashImages.length === 0) {
    _Logger().default.global.warn(`Splash resizeMode is set to 'native', but you haven't provided any images for different DPIs.
Be aware that your splash image will be used as xxxhdpi asset and its ${_chalk().default.bold('actual size will be different')} depending on device's DPI.
See https://docs.expo.io/guides/splash-screens/#splash-screen-api-limitations-on-android for more information`);

    return;
  }

  if (androidSplashImages.some(({
    sizeMatches
  }) => !sizeMatches)) {
    _Logger().default.global.warn(`Splash resizeMode is set to 'native' and you've provided different images for different DPIs,
but their sizes mismatch expected ones: [dpi: provided (expected)] ${androidSplashImages.map(({
      dpi,
      width,
      height,
      expectedWidth,
      expectedHeight
    }) => `${dpi}: ${width}x${height} (${expectedWidth}x${expectedHeight})`).join(', ')}
See https://docs.expo.io/guides/splash-screens/#splash-screen-api-limitations-on-android for more information`);
  }
}

async function maybeStopAdbDaemonAsync() {
  try {
    await getAdbOutputAsync(['kill-server']);
    return true;
  } catch (_unused2) {
    return false;
  }
}
//# sourceMappingURL=__sourcemaps__/Android.js.map
