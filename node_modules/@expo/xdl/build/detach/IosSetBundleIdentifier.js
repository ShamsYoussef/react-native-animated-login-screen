"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resetAllPlistBundleIdentifiers = resetAllPlistBundleIdentifiers;
exports.resetPlistBundleIdentifier = resetPlistBundleIdentifier;
exports.updateBundleIdentifierForPbxproj = updateBundleIdentifierForPbxproj;
exports.setBundleIdentifier = setBundleIdentifier;

function _fs() {
  const data = _interopRequireDefault(require("fs"));

  _fs = function () {
    return data;
  };

  return data;
}

function _glob() {
  const data = require("glob");

  _glob = function () {
    return data;
  };

  return data;
}

function _xcode() {
  const data = require("xcode");

  _xcode = function () {
    return data;
  };

  return data;
}

function _plist() {
  const data = _interopRequireDefault(require("@expo/plist"));

  _plist = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// @ts-ignore
const defaultBundleId = '$(PRODUCT_BUNDLE_IDENTIFIER)';

function resetAllPlistBundleIdentifiers(projectRoot) {
  const infoPlistPaths = (0, _glob().sync)('ios/*/Info.plist', {
    absolute: true,
    cwd: projectRoot
  });

  for (const plistPath of infoPlistPaths) {
    resetPlistBundleIdentifier(plistPath);
  }
}

function resetPlistBundleIdentifier(plistPath) {
  // Read Plist as source
  const rawPlist = _fs().default.readFileSync(plistPath, 'utf8');

  const plistObject = _plist().default.parse(rawPlist);

  if (plistObject.CFBundleIdentifier) {
    // Maybe bail out
    if (plistObject.CFBundleIdentifier === defaultBundleId) return; // attempt to match default Info.plist format

    const format = {
      pretty: true,
      indent: `\t`
    };

    const xml = _plist().default.build({ ...plistObject,
      CFBundleIdentifier: defaultBundleId
    }, format);

    if (xml !== rawPlist) {
      _fs().default.writeFileSync(plistPath, xml);
    }
  }
}

function filterComments([item]) {
  return !item.endsWith(`_comment`);
}

function filterConfig(input) {
  const {
    1: {
      isa
    }
  } = input;
  return isa === 'XCBuildConfiguration';
}

function filterHosts(input) {
  const {
    1: {
      buildSettings
    }
  } = input;
  return !buildSettings.TEST_HOST;
}

function updateBundleIdentifierForPbxproj(pbxprojPath, bundleIdentifier) {
  const project = (0, _xcode().project)(pbxprojPath);
  project.parseSync();
  Object.entries(project.pbxXCBuildConfigurationSection()).filter(filterComments).filter(filterConfig).filter(filterHosts).forEach(({
    1: {
      buildSettings
    }
  }) => {
    if (buildSettings.PRODUCT_BUNDLE_IDENTIFIER === bundleIdentifier) {
      return;
    }

    buildSettings.PRODUCT_BUNDLE_IDENTIFIER = `"${bundleIdentifier}"`;
    const productName = bundleIdentifier.split('.').pop();

    if (!(productName === null || productName === void 0 ? void 0 : productName.includes('$'))) {
      buildSettings.PRODUCT_NAME = productName;
    }
  });

  _fs().default.writeFileSync(pbxprojPath, project.writeSync());
}

function setBundleIdentifier(projectRoot, bundleIdentifier) {
  // Get all pbx projects
  const pbxprojPaths = (0, _glob().sync)('ios/*/project.pbxproj', {
    absolute: true,
    cwd: projectRoot
  });

  for (const pbxprojPath of pbxprojPaths) {
    updateBundleIdentifierForPbxproj(pbxprojPath, bundleIdentifier);
  }
}
//# sourceMappingURL=../__sourcemaps__/detach/IosSetBundleIdentifier.js.map
