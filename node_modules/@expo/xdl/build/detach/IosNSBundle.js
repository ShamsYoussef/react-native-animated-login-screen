"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configureAsync = configureAsync;

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function AssetBundle() {
  const data = _interopRequireWildcard(require("./AssetBundle"));

  AssetBundle = function () {
    return data;
  };

  return data;
}

function _ExponentTools() {
  const data = require("./ExponentTools");

  _ExponentTools = function () {
    return data;
  };

  return data;
}

function IosAssetArchive() {
  const data = _interopRequireWildcard(require("./IosAssetArchive"));

  IosAssetArchive = function () {
    return data;
  };

  return data;
}

function IosIcons() {
  const data = _interopRequireWildcard(require("./IosIcons"));

  IosIcons = function () {
    return data;
  };

  return data;
}

function IosLaunchScreen() {
  const data = _interopRequireWildcard(require("./IosLaunchScreen"));

  IosLaunchScreen = function () {
    return data;
  };

  return data;
}

function IosLocalization() {
  const data = _interopRequireWildcard(require("./IosLocalization"));

  IosLocalization = function () {
    return data;
  };

  return data;
}

function IosPlist() {
  const data = _interopRequireWildcard(require("./IosPlist"));

  IosPlist = function () {
    return data;
  };

  return data;
}

function IosWorkspace() {
  const data = _interopRequireWildcard(require("./IosWorkspace"));

  IosWorkspace = function () {
    return data;
  };

  return data;
}

function _Logger() {
  const data = _interopRequireDefault(require("./Logger"));

  _Logger = function () {
    return data;
  };

  return data;
}

function _StandaloneContext() {
  const data = require("./StandaloneContext");

  _StandaloneContext = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// @ts-ignore: No TS support
// @ts-ignore: No TS support
// @ts-ignore: No TS support
// TODO: move this somewhere else. this is duplicated in universe/exponent/template-files/keys,
// but xdl doesn't have access to that.
const DEFAULT_FABRIC_KEY = '81130e95ea13cd7ed9a4f455e96214902c721c99';
const DEFAULT_GAD_APPLICATION_ID = 'ca-app-pub-3940256099942544~1458002511';
const KERNEL_URL = 'https://expo.io/@exponent/home';

function _configureInfoPlistForLocalDevelopment(config, exp) {
  var _exp$detach;

  // add detached scheme
  if (exp.isDetached && ((_exp$detach = exp.detach) === null || _exp$detach === void 0 ? void 0 : _exp$detach.scheme)) {
    if (!config.CFBundleURLTypes) {
      config.CFBundleURLTypes = [{
        CFBundleURLSchemes: []
      }];
    }

    config.CFBundleURLTypes[0].CFBundleURLSchemes.push(exp.detach.scheme);
  } // for local dev, don't specify device family here


  if (config.UIDeviceFamily) {
    delete config.UIDeviceFamily;
  }

  return config;
}
/**
 *  Prints warnings or info about the configured environment for local development.
 */


function _logDeveloperInfoForLocalDevelopment(infoPlist) {
  // warn about *UsageDescription changes
  let usageKeysConfigured = [];

  for (let key in infoPlist) {
    if (key in infoPlist && key.includes('UsageDescription')) {
      usageKeysConfigured.push(key);
    }
  }

  if (usageKeysConfigured.length) {
    _Logger().default.info('We added some permissions keys to `Info.plist` in your detached iOS project:');

    usageKeysConfigured.forEach(key => {
      _Logger().default.info(`  ${key}`);
    });

    _Logger().default.info('You may want to revise them to include language appropriate to your project. You can also remove them if your app will never use the corresponding API. See the Apple docs for these keys.');
  }
}

async function _cleanPropertyListBackupsAsync(context, backupPath) {
  var _context$build, _context$build$ios;

  if (((_context$build = context.build) === null || _context$build === void 0 ? void 0 : (_context$build$ios = _context$build.ios) === null || _context$build$ios === void 0 ? void 0 : _context$build$ios.buildType) !== 'client') {
    await IosPlist().cleanBackupAsync(backupPath, 'EXShell', false); // [dsokal] it's probably ok to clean up those two for client but no one knows if it's true for sure

    await IosPlist().cleanBackupAsync(backupPath, 'EXSDKVersions', false);
    await IosPlist().cleanBackupAsync(backupPath, 'EXBuildConstants', false);
  }

  await IosPlist().cleanBackupAsync(backupPath, 'Info', false); // TODO: support this in user contexts as well

  if (context instanceof _StandaloneContext().StandaloneContextService) {
    const {
      projectName
    } = IosWorkspace().getPaths(context);
    await IosPlist().cleanBackupAsync(backupPath, `${projectName}.entitlements`, false);
  }
}
/**
 * Write the manifest and JS bundle to the NSBundle.
 */


async function _preloadManifestAndBundleAsync(manifest, supportingDirectory, manifestFilename, bundleFilename) {
  const bundleUrl = manifest.bundleUrl;
  await _fsExtra().default.writeFile(_path().default.join(supportingDirectory, manifestFilename), JSON.stringify(manifest));
  await (0, _ExponentTools().saveUrlToPathAsync)(bundleUrl, _path().default.join(supportingDirectory, bundleFilename));
}
/**
 *  This method only makes sense when operating on a context with sdk version < 26.
 */


async function _maybeLegacyPreloadKernelManifestAndBundleAsync(context, manifestFilename, bundleFilename) {
  const {
    supportingDirectory
  } = IosWorkspace().getPaths(context);
  let sdkVersionSupported = await IosWorkspace().getNewestSdkVersionSupportedAsync(context);

  if ((0, _ExponentTools().parseSdkMajorVersion)(sdkVersionSupported) < 26) {
    _Logger().default.info('Preloading Expo kernel JS...');

    const kernelManifest = await (0, _ExponentTools().getManifestAsync)(KERNEL_URL, {
      'Exponent-SDK-Version': sdkVersionSupported,
      'Exponent-Platform': 'ios',
      Accept: 'application/expo+json,application/json'
    });
    return _preloadManifestAndBundleAsync(kernelManifest, supportingDirectory, manifestFilename, bundleFilename);
  }
}
/**
 * Configure a standalone entitlements file.
 */


async function _configureEntitlementsAsync(context) {
  if (context instanceof _StandaloneContext().StandaloneContextUser) {
    // don't modify .entitlements, print info/instructions
    const {
      exp
    } = context.data;

    _Logger().default.info('Your iOS ExpoKit project will not contain an .entitlements file by default. If you need specific Apple entitlements, enable them manually via Xcode or the Apple Developer website.');

    let keysToFlag = [];

    if (exp.ios && exp.ios.usesIcloudStorage) {
      keysToFlag.push('ios.usesIcloudStorage');
    }

    if (exp.ios && exp.ios.associatedDomains) {
      keysToFlag.push('ios.associatedDomains');
    }

    if (keysToFlag.length) {
      _Logger().default.info('We noticed the following keys in your project which may require entitlements:');

      keysToFlag.forEach(key => {
        _Logger().default.info(`  ${key}`);
      });
    }

    return {};
  } else {
    // modify the .entitlements file
    const {
      projectName,
      supportingDirectory
    } = IosWorkspace().getPaths(context);
    const manifest = (0, _StandaloneContext().isStandaloneContextDataService)(context.data) && context.data.manifest;
    const entitlementsFilename = `${projectName}.entitlements`;
    const {
      appleTeamId
    } = context.build.ios || {};

    if (!_fsExtra().default.existsSync(_path().default.join(supportingDirectory, entitlementsFilename))) {
      await IosPlist().createBlankAsync(supportingDirectory, entitlementsFilename);
    }

    const result = IosPlist().modifyAsync(supportingDirectory, entitlementsFilename, entitlements => {
      // push notif entitlement changes based on build configuration
      entitlements['aps-environment'] = context.build.configuration === 'Release' ? 'production' : 'development'; // remove iCloud-specific entitlements if the developer isn't using iCloud Storage with DocumentPicker

      if (manifest.ios && manifest.ios.usesIcloudStorage && appleTeamId) {
        entitlements['com.apple.developer.icloud-container-identifiers'] = ['iCloud.' + manifest.ios.bundleIdentifier];
        entitlements['com.apple.developer.ubiquity-container-identifiers'] = ['iCloud.' + manifest.ios.bundleIdentifier];
        entitlements['com.apple.developer.ubiquity-kvstore-identifier'] = appleTeamId + '.' + manifest.ios.bundleIdentifier;
        entitlements['com.apple.developer.icloud-services'] = ['CloudDocuments'];
      } else {
        ['com.apple.developer.icloud-container-identifiers', 'com.apple.developer.icloud-services', 'com.apple.developer.ubiquity-container-identifiers', 'com.apple.developer.ubiquity-kvstore-identifier'].forEach(key => {
          if (entitlements.hasOwnProperty(key)) {
            delete entitlements[key];
          }
        });
      }

      if (manifest.ios && manifest.ios.usesAppleSignIn) {
        entitlements['com.apple.developer.applesignin'] = ['Default'];
      } else if (entitlements.hasOwnProperty('com.apple.developer.applesignin')) {
        delete entitlements['com.apple.developer.applesignin'];
      }

      if (manifest.ios && manifest.ios.accessesContactNotes) {
        entitlements['com.apple.developer.contacts.notes'] = manifest.ios.accessesContactNotes;
      } else if (entitlements.hasOwnProperty('com.apple.developer.contacts.notes')) {
        delete entitlements['com.apple.developer.contacts.notes'];
      } // Add app associated domains remove exp-specific ones.


      if (manifest.ios && manifest.ios.associatedDomains) {
        entitlements['com.apple.developer.associated-domains'] = manifest.ios.associatedDomains;
      } else if (entitlements.hasOwnProperty('com.apple.developer.associated-domains')) {
        delete entitlements['com.apple.developer.associated-domains'];
      } // for now, remove any merchant ID in shell apps
      // (TODO: better plan for payments)


      delete entitlements['com.apple.developer.in-app-payments'];
      return entitlements;
    });
    return result;
  }
}
/**
 *  Resolve the private config for a project.
 *  For standalone apps, this is copied into a separate context field context.data.privateConfig
 *  by the turtle builder. For a local project, this is available in app.json under ios.config.
 */


function _getPrivateConfig(context) {
  if (context instanceof _StandaloneContext().StandaloneContextService) {
    return context.data.privateConfig;
  } else {
    const exp = context.data.exp;

    if (exp && exp.ios) {
      return exp.ios.config;
    }
  }

  return undefined;
}

function _isAppleUsageDescriptionKey(key) {
  return key.includes('UsageDescription');
}
/**
 * Configure an iOS Info.plist for a standalone app.
 */


async function _configureInfoPlistAsync(context) {
  const {
    supportingDirectory
  } = IosWorkspace().getPaths(context);
  const config = context.config;

  const privateConfig = _getPrivateConfig(context);

  let result = await IosPlist().modifyAsync(supportingDirectory, 'Info', infoPlist => {
    var _extraConfig;

    // make sure this happens first:
    // apply any custom information from ios.infoPlist prior to all other exponent config
    let usageDescriptionKeysConfigured = {};
    let extraConfig;

    if (config.ios && config.ios.infoPlist) {
      extraConfig = config.ios.infoPlist;

      for (let key in extraConfig) {
        if (extraConfig.hasOwnProperty(key)) {
          infoPlist[key] = extraConfig[key]; // if the user provides *UsageDescription keys, don't override them later.

          if (_isAppleUsageDescriptionKey(key)) {
            usageDescriptionKeysConfigured[key] = true;
          }
        }
      }
    } // reset the status bar style to the default gray. this can be removed if we
    // ever change expo client to use `UIStatusBarStyleDefault` instead of
    // `UIStatusBarStyleLightContent`


    if (!((_extraConfig = extraConfig) === null || _extraConfig === void 0 ? void 0 : _extraConfig.UIStatusBarStyle)) {
      infoPlist.UIStatusBarStyle = 'UIStatusBarStyleDefault';
    } // bundle id


    infoPlist.CFBundleIdentifier = config.ios && config.ios.bundleIdentifier ? config.ios.bundleIdentifier : null;

    if (!infoPlist.CFBundleIdentifier) {
      throw new Error(`Cannot configure an iOS app with no bundle identifier.`);
    } // app name


    infoPlist.CFBundleName = config.name;
    infoPlist.CFBundleDisplayName = context.build.isExpoClientBuild() ? 'Expo (Custom)' : config.name; // determine app linking schemes

    let linkingSchemes = config.scheme ? [config.scheme] : [];

    if (config.facebookScheme && config.facebookScheme.startsWith('fb')) {
      linkingSchemes.push(config.facebookScheme);
    }

    if (privateConfig && privateConfig.googleSignIn && privateConfig.googleSignIn.reservedClientId) {
      linkingSchemes.push(privateConfig.googleSignIn.reservedClientId);
    } // remove exp scheme, add app scheme(s)


    infoPlist.CFBundleURLTypes = [{
      CFBundleURLSchemes: linkingSchemes
    }, {
      // Add the generic oauth redirect, it's important that it has the name
      // 'OAuthRedirect' so we can find it in app code.
      CFBundleURLName: 'OAuthRedirect',
      CFBundleURLSchemes: [infoPlist.CFBundleIdentifier]
    }]; // add or remove other facebook config

    if (config.facebookAppId) {
      infoPlist.FacebookAppID = config.facebookAppId;
      let queriesSchemes = infoPlist.LSApplicationQueriesSchemes || [];
      queriesSchemes = queriesSchemes.concat(['fbapi', 'fb-messenger-api', 'fbauth2', 'fbshareextension']);
      infoPlist.LSApplicationQueriesSchemes = queriesSchemes;
    } else {
      delete infoPlist['FacebookAppID'];
    }

    if (config.facebookDisplayName) {
      infoPlist.FacebookDisplayName = config.facebookDisplayName;
    } else {
      delete infoPlist['FacebookDisplayName'];
    }

    if ((0, _ExponentTools().parseSdkMajorVersion)(config.sdkVersion) >= 36) {
      infoPlist.FacebookAutoInitEnabled = config.facebookAutoInitEnabled || false;
      infoPlist.FacebookAutoLogAppEventsEnabled = config.facebookAutoLogAppEventsEnabled || false;
      infoPlist.FacebookAdvertiserIDCollectionEnabled = config.facebookAdvertiserIDCollectionEnabled || false;
    } // set ITSAppUsesNonExemptEncryption to let people skip manually
    // entering it in iTunes Connect


    if (privateConfig && privateConfig.hasOwnProperty('usesNonExemptEncryption') && privateConfig.usesNonExemptEncryption === false) {
      infoPlist.ITSAppUsesNonExemptEncryption = false;
    } // google maps api key


    if (privateConfig && privateConfig.googleMapsApiKey) {
      infoPlist.GMSApiKey = privateConfig.googleMapsApiKey;
    } // Google Mobile Ads App ID
    // The app crashes if the app ID isn't provided, so if the user
    // doesn't provide the ID, we leave the sample one.


    infoPlist.GADApplicationIdentifier = privateConfig && privateConfig.googleMobileAdsAppId || DEFAULT_GAD_APPLICATION_ID; // Auto-init of Google App Measurement
    // unless the user explicitly specifies they want to auto-init, we set delay to true

    infoPlist.GADDelayAppMeasurementInit = !(privateConfig && privateConfig.googleMobileAdsAutoInit); // use version from manifest

    let version = config.version ? config.version : '0.0.0';
    let buildNumber = config.ios && config.ios.buildNumber ? config.ios.buildNumber : '1';
    infoPlist.CFBundleShortVersionString = version;
    infoPlist.CFBundleVersion = buildNumber;
    infoPlist.Fabric = {
      APIKey: privateConfig && privateConfig.fabric && privateConfig.fabric.apiKey || DEFAULT_FABRIC_KEY,
      Kits: [{
        KitInfo: {},
        KitName: 'Crashlytics'
      }]
    };

    if (privateConfig && privateConfig.branch) {
      infoPlist.branch_key = {
        live: privateConfig.branch.apiKey
      };
    }

    let permissionsAppName = config.name ? config.name : 'this app';

    for (let key in infoPlist) {
      if (infoPlist.hasOwnProperty(key) && _isAppleUsageDescriptionKey(key) && !usageDescriptionKeysConfigured.hasOwnProperty(key)) {
        infoPlist[key] = infoPlist[key].replace('Expo experiences', permissionsAppName);
      }
    } // 1 is iPhone, 2 is iPad


    infoPlist.UIDeviceFamily = config.ios && config.ios.supportsTablet ? [1, 2] : [1]; // allow iPad-only

    if (config.ios && config.ios.isTabletOnly) {
      infoPlist.UIDeviceFamily = [2];
    } // Whether requires full screen on iPad


    infoPlist.UIRequiresFullScreen = config.ios && config.ios.requireFullScreen;

    if (infoPlist.UIRequiresFullScreen == null) {
      // NOTES: This is defaulted to `true` for now to match the behavior prior to SDK 34, but will change to `false` in a future SDK version.
      infoPlist.UIRequiresFullScreen = true;
    } // Cast to make sure that it is a boolean.


    infoPlist.UIRequiresFullScreen = Boolean(infoPlist.UIRequiresFullScreen); // Put `ios.userInterfaceStyle` into `UIUserInterfaceStyle` property of Info.plist

    const userInterfaceStyle = config.ios && config.ios.userInterfaceStyle;

    if (userInterfaceStyle) {
      // To convert our config value to the InfoPlist value, we can just capitalize it.
      infoPlist.UIUserInterfaceStyle = _mapUserInterfaceStyleForInfoPlist(userInterfaceStyle);
    } // context-specific plist changes


    if (context instanceof _StandaloneContext().StandaloneContextUser) {
      infoPlist = _configureInfoPlistForLocalDevelopment(infoPlist, context.data.exp);

      _logDeveloperInfoForLocalDevelopment(infoPlist);
    }

    if (context instanceof _StandaloneContext().StandaloneContextService && context.build.ios) {
      infoPlist.CFBundleExecutable = context.build.ios.bundleExecutable;
    }

    return infoPlist;
  });
  return result;
}
/**
 *  Configure EXShell.plist for a standalone app.
 */


async function _configureShellPlistAsync(context) {
  const {
    supportingDirectory
  } = IosWorkspace().getPaths(context);
  const config = context.config;

  const buildPhaseLogger = _Logger().default.withFields({
    buildPhase: 'configuring NSBundle'
  });

  await IosPlist().modifyAsync(supportingDirectory, 'EXShell', shellPlist => {
    // older SDK versions rely on `isShell` flag in xdl
    if ((0, _ExponentTools().parseSdkMajorVersion)(config.sdkVersion) < 28) {
      shellPlist.isShell = true;
    }

    shellPlist.manifestUrl = context.published.url;
    shellPlist.releaseChannel = context.published.releaseChannel;

    if ((0, _StandaloneContext().isStandaloneContextDataService)(context.data) && context.data.testEnvironment) {
      shellPlist.testEnvironment = context.data.testEnvironment;
    }

    if (config.ios && config.ios.permissions) {
      shellPlist.permissions = config.ios.permissions;
    }

    if (context instanceof _StandaloneContext().StandaloneContextUser) {
      // disable manifest verification on detached apps until
      // the developer adds the correct entitlements to their bundle id.
      shellPlist.isManifestVerificationBypassed = true;
    }

    if (config.ios && config.ios.hasOwnProperty('isRemoteJSEnabled')) {
      // deprecated, overridden by updates.enabled if that exists
      shellPlist.areRemoteUpdatesEnabled = config.ios.isRemoteJSEnabled;
    }

    if (config.updates && config.updates.hasOwnProperty('enabled')) {
      // enable/disable code push if the developer provided specific behavior
      shellPlist.areRemoteUpdatesEnabled = config.updates.enabled;
    }

    if (!(0, _ExponentTools().manifestUsesSplashApi)(config, 'ios') && (0, _ExponentTools().parseSdkMajorVersion)(config.sdkVersion) < 28) {
      // for people still using the old loading api, hide the native splash screen.
      // we can remove this code eventually.
      shellPlist.isSplashScreenDisabled = true;
    }

    buildPhaseLogger.info('Using standalone config:', shellPlist);
    return shellPlist;
  });
}

async function _configureConstantsPlistAsync(context) {
  if (context instanceof _StandaloneContext().StandaloneContextUser) {
    return;
  }

  const {
    supportingDirectory
  } = IosWorkspace().getPaths(context);
  await IosPlist().modifyAsync(supportingDirectory, 'EXBuildConstants', constantsConfig => {
    constantsConfig.API_SERVER_ENDPOINT = process.env.ENVIRONMENT === 'staging' ? 'https://staging.exp.host/--/api/v2/' : 'https://exp.host/--/api/v2/';
    return constantsConfig;
  });
}

async function _configureGoogleServicesPlistAsync(context) {
  var _context$data$manifes;

  if (context instanceof _StandaloneContext().StandaloneContextUser) {
    return;
  }

  if ((_context$data$manifes = context.data.manifest.ios) === null || _context$data$manifes === void 0 ? void 0 : _context$data$manifes.googleServicesFile) {
    var _context$data$manifes2;

    const {
      supportingDirectory
    } = IosWorkspace().getPaths(context);
    await _fsExtra().default.writeFile(_path().default.join(supportingDirectory, 'GoogleService-Info.plist'), (_context$data$manifes2 = context.data.manifest.ios) === null || _context$data$manifes2 === void 0 ? void 0 : _context$data$manifes2.googleServicesFile, 'base64');
  }
}

async function configureAsync(context) {
  const buildPhaseLogger = _Logger().default.withFields({
    buildPhase: 'configuring NSBundle'
  });

  let {
    intermediatesDirectory,
    iosProjectDirectory,
    projectName,
    supportingDirectory
  } = IosWorkspace().getPaths(context);
  const isExpoClientBuild = context.build.isExpoClientBuild();

  if (!isExpoClientBuild && !context.published.url) {
    throw new Error(`Can't configure a NSBundle without a published url.`);
  } // ensure the intermediates directory is clean of any prior build's artifacts, in the event we
  // share directories across builds


  await _fsExtra().default.remove(intermediatesDirectory);

  try {
    // common configuration for all contexts
    buildPhaseLogger.info(`Modifying NSBundle configuration at ${supportingDirectory}...`);
    await _configureInfoPlistAsync(context);

    if (!isExpoClientBuild) {
      await _configureShellPlistAsync(context);
    }

    await _configureEntitlementsAsync(context);
    await _configureConstantsPlistAsync(context);
    await _configureGoogleServicesPlistAsync(context);

    if (!isExpoClientBuild) {
      await IosLaunchScreen().configureLaunchAssetsAsync(context, intermediatesDirectory);
      await IosLocalization().writeLocalizationResourcesAsync({
        supportingDirectory,
        context
      });
    }

    if (isExpoClientBuild) {
      return;
    }

    if (context instanceof _StandaloneContext().StandaloneContextUser) {
      const iconPath = _path().default.join(iosProjectDirectory, projectName, 'Assets.xcassets', 'AppIcon.appiconset');

      await IosIcons().createAndWriteIconsToPathAsync(context, iconPath);
    } else if (context instanceof _StandaloneContext().StandaloneContextService) {
      buildPhaseLogger.info('Bundling assets...');

      try {
        await AssetBundle().bundleAsync(context, context.data.manifest.bundledAssets, supportingDirectory);
      } catch (e) {
        throw new Error(`Asset bundling failed: ${e}`);
      }

      buildPhaseLogger.info('Compiling resources...');
      await IosAssetArchive().buildAssetArchiveAsync(context, supportingDirectory, intermediatesDirectory);
      await _preloadManifestAndBundleAsync(context.data.manifest, supportingDirectory, 'shell-app-manifest.json', 'shell-app.bundle');
    }

    await _maybeLegacyPreloadKernelManifestAndBundleAsync(context, 'kernel-manifest.json', 'kernel.ios.bundle');
  } catch (err) {
    console.error(err);
    throw err;
  } finally {
    buildPhaseLogger.info('Cleaning up iOS...');
    await Promise.all([_cleanPropertyListBackupsAsync(context, supportingDirectory), _fsExtra().default.remove(intermediatesDirectory)]);
  }
}

function _mapUserInterfaceStyleForInfoPlist(userInterfaceStyle) {
  switch (userInterfaceStyle) {
    case 'light':
      return 'Light';

    case 'dark':
      return 'Dark';

    case 'automatic':
      return 'Automatic';

    default:
      _Logger().default.warn(`User interface style "${userInterfaceStyle}" is not supported. Supported values: "light", "dark", "automatic".`);

  }

  return undefined;
}
//# sourceMappingURL=../__sourcemaps__/detach/IosNSBundle.js.map
