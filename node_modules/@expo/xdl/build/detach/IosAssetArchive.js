"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildAssetArchiveAsync = buildAssetArchiveAsync;

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _ExponentTools() {
  const data = require("./ExponentTools");

  _ExponentTools = function () {
    return data;
  };

  return data;
}

function IosIcons() {
  const data = _interopRequireWildcard(require("./IosIcons"));

  IosIcons = function () {
    return data;
  };

  return data;
}

function _StandaloneContext() {
  const data = require("./StandaloneContext");

  _StandaloneContext = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *  Compile a .car file from the icons in a manifest.
 */
async function buildAssetArchiveAsync(context, destinationCARPath, intermediatesDirectory) {
  if (!(context instanceof _StandaloneContext().StandaloneContextService)) {
    throw new Error('buildAssetArchive is only supported for service standalone contexts.');
  }

  const {
    data
  } = context;

  _fsExtra().default.mkdirpSync(intermediatesDirectory); // copy expoSourceRoot/.../Images.xcassets into intermediates


  await (0, _ExponentTools().spawnAsyncThrowError)('/bin/cp', ['-R', _path().default.join(data.expoSourcePath, 'Exponent', 'Images.xcassets'), _path().default.join(intermediatesDirectory, 'Images.xcassets')], {
    stdio: 'inherit'
  }); // make the new xcassets contain the project's icon

  await IosIcons().createAndWriteIconsToPathAsync(context, _path().default.join(intermediatesDirectory, 'Images.xcassets', 'AppIcon.appiconset'));
  const sdkMajorVersion = (0, _ExponentTools().parseSdkMajorVersion)(data.manifest.sdkVersion);
  const deploymentTarget = sdkMajorVersion > 30 ? '10.0' : '9.0'; // SDK31 drops support for iOS 9.0
  // compile asset archive
  // prettier-ignore

  const xcrunargs = ['actool', '--minimum-deployment-target', deploymentTarget, '--platform', 'iphoneos', '--app-icon', 'AppIcon', '--output-partial-info-plist', 'assetcatalog_generated_info.plist', '--compress-pngs', '--enable-on-demand-resources', 'YES', '--product-type', 'com.apple.product-type.application', '--target-device', 'iphone', '--target-device', 'ipad', '--compile', _path().default.relative(intermediatesDirectory, destinationCARPath), 'Images.xcassets'];
  /*
   *  Note: if you want to debug issues with `actool`, try changing to stdio: 'inherit'.
   *  In both success and failure cases, actool will write an enormous .plist to stdout
   *  which may contain the key `com.apple.actool.errors`. Great work Apple
   */

  await (0, _ExponentTools().spawnAsyncThrowError)('xcrun', xcrunargs, {
    stdio: ['ignore', 'ignore', 'inherit'],
    // only stderr
    cwd: intermediatesDirectory
  });
}
//# sourceMappingURL=../__sourcemaps__/detach/IosAssetArchive.js.map
