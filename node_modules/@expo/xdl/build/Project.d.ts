import { ExpoConfig, Hook, HookArguments, ProjectTarget } from '@expo/config';
declare type LoadedHook = Hook & {
    _fn: (input: HookArguments) => any;
};
export declare type StartOptions = {
    reset?: boolean;
    nonInteractive?: boolean;
    nonPersistent?: boolean;
    maxWorkers?: number;
    webOnly?: boolean;
    target?: ProjectTarget;
};
declare type PublishOptions = {
    releaseChannel?: string;
    target?: ProjectTarget;
};
declare type Release = {
    fullName: string;
    channel: string;
    channelId: string;
    publicationId: string;
    appVersion: string;
    sdkVersion: string;
    publishedTime: string;
    platform: string;
};
export declare type ProjectStatus = 'running' | 'ill' | 'exited';
export declare function currentStatus(projectDir: string): Promise<ProjectStatus>;
export declare function getManifestUrlWithFallbackAsync(projectRoot: string): Promise<{
    url: string;
    isUrlFallback: false;
}>;
export declare function getSlugAsync(projectRoot: string): Promise<string>;
export declare function getLatestReleaseAsync(projectRoot: string, options: {
    releaseChannel: string;
    platform: string;
    owner?: string;
}): Promise<Release | null>;
export declare function mergeAppDistributions(projectRoot: string, sourceDirs: Array<string>, outputDir: string): Promise<void>;
export declare function runHook(hook: LoadedHook, hookOptions: Omit<HookArguments, 'config'>): Promise<void>;
/**
 * Apps exporting for self hosting will have the files created in the project directory the following way:
.
├── android-index.json
├── ios-index.json
├── assets
│   └── 1eccbc4c41d49fd81840aef3eaabe862
└── bundles
      ├── android-01ee6e3ab3e8c16a4d926c91808d5320.js
      └── ios-ee8206cc754d3f7aa9123b7f909d94ea.js
 */
export declare function exportForAppHosting(projectRoot: string, publicUrl: string, assetUrl: string, outputDir: string, options?: {
    isDev?: boolean;
    dumpAssetmap?: boolean;
    dumpSourcemap?: boolean;
    publishOptions?: PublishOptions;
}): Promise<void>;
export declare function findReusableBuildAsync(releaseChannel: string, platform: string, sdkVersion: string, slug: string): Promise<{
    downloadUrl?: string;
    canReuse: boolean;
}>;
export declare function publishAsync(projectRoot: string, options?: PublishOptions): Promise<{
    url: string;
    ids: string[];
    err?: string;
}>;
declare type GetExpConfigOptions = {
    current?: boolean;
    mode?: string;
    platform?: 'android' | 'ios' | 'all';
    expIds?: string[];
    type?: string;
    releaseChannel?: string;
    bundleIdentifier?: string;
    publicUrl?: string;
    sdkVersion?: string;
};
declare type JobState = 'pending' | 'started' | 'in-progress' | 'finished' | 'errored' | 'sent-to-queue';
export declare type TurtleMode = 'normal' | 'high' | 'high_only';
export interface BuildJobFields {
    id: string;
    experienceName: string;
    status: JobState;
    platform: 'ios' | 'android';
    userId: string | null;
    experienceId: string;
    artifactId: string | null;
    nonce: string | null;
    artifacts: {
        url?: string;
        manifestPlistUrl?: string;
    } | null;
    config: {
        buildType?: string;
        releaseChannel?: string;
        bundleIdentifier?: string;
    };
    logs: object | null;
    extraData: {
        request_id?: string;
        turtleMode?: TurtleMode;
    } | null;
    created: Date;
    updated: Date;
    expirationDate: Date;
    sdkVersion: string | null;
    turtleVersion: string | null;
    buildDuration: number | null;
    priority: string;
    accountId: string | null;
}
export declare type BuildStatusResult = {
    jobs: BuildJobFields[];
    err: null;
    userHasBuiltAppBefore: boolean;
    userHasBuiltExperienceBefore: boolean;
    canPurchasePriorityBuilds: boolean;
    numberOfRemainingPriorityBuilds: number;
    hasUnlimitedPriorityBuilds: boolean;
};
export declare type BuildCreatedResult = {
    id: string;
    ids: string[];
    priority: 'normal' | 'high';
    canPurchasePriorityBuilds: boolean;
    numberOfRemainingPriorityBuilds: number;
    hasUnlimitedPriorityBuilds: boolean;
};
export declare function getBuildStatusAsync(projectRoot: string, options?: GetExpConfigOptions): Promise<BuildStatusResult>;
export declare function startBuildAsync(projectRoot: string, options?: GetExpConfigOptions): Promise<BuildCreatedResult>;
export declare function startReactNativeServerAsync(projectRoot: string, options?: StartOptions, verbose?: boolean): Promise<void>;
export declare function stopReactNativeServerAsync(projectRoot: string): Promise<void>;
export declare function startExpoServerAsync(projectRoot: string): Promise<void>;
export declare function stopExpoServerAsync(projectRoot: string): Promise<void>;
export declare function startTunnelsAsync(projectRoot: string): Promise<void>;
export declare function stopTunnelsAsync(projectRoot: string): Promise<void>;
export declare function setOptionsAsync(projectRoot: string, options: {
    packagerPort?: number;
}): Promise<void>;
export declare function getUrlAsync(projectRoot: string, options?: object): Promise<string>;
export declare function startAsync(projectRoot: string, options?: StartOptions, verbose?: boolean): Promise<ExpoConfig>;
export declare function stopWebOnlyAsync(projectDir: string): Promise<void>;
export declare function stopAsync(projectDir: string): Promise<void>;
export {};
