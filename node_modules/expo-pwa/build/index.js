"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("@expo/config");
const Image = __importStar(require("@expo/image-utils"));
const path = __importStar(require("path"));
const Splash_1 = require("./Splash");
const Manifest_1 = require("./Manifest");
exports.getConfigForPWA = Manifest_1.getConfigForPWA;
async function generateAsync(type, options, icon) {
    switch (type) {
        case 'splash':
            return generateSplashAsync(options, icon);
        case 'safari-icon':
            return generateAppleIconAsync(options, icon, {});
        case 'chrome-icon':
            return generateChromeIconAsync(options, icon, {});
        case 'favicon':
            return generateFaviconAsync(options, icon);
    }
    throw new Error(`Invalid command type: ${type}`);
}
exports.generateAsync = generateAsync;
async function generateSplashAsync({ projectRoot, publicPath }, icon) {
    const cacheType = 'apple-touch-startup-image';
    // You cannot lock iOS PWA orientation, we should produce every splash screen
    // orientation. We don't however because in iOS 13 it's far more rare to see landscape splash screens.
    const devices = Splash_1.getDevices();
    const icons = Array.isArray(icon) ? icon : [];
    if (!Array.isArray(icon)) {
        for (const device of devices) {
            for (const orientation of device.orientations) {
                let width = 0;
                let height = 0;
                if (orientation !== 'portrait') {
                    width = device.height;
                    height = device.width;
                }
                else {
                    height = device.height;
                    width = device.width;
                }
                const name = `apple-touch-startup-image-${width}x${height}.png`;
                icons.push(Object.assign(Object.assign({}, icon), { name,
                    width,
                    height, media: Splash_1.assembleOrientationMedia(device.width, device.height, device.scale, orientation) }));
            }
        }
    }
    const data = await Promise.all(icons.map(async (icon) => {
        // Ensure the default `splash.resizeMode` is used here:
        // https://docs.expo.io/workflow/configuration/#splash
        if (!icon.resizeMode) {
            icon.resizeMode = 'contain';
        }
        const { source, name } = await Image.generateImageAsync({ projectRoot, cacheType }, icon);
        const href = `pwa/apple-touch-startup-image/${name}`;
        return {
            asset: {
                source,
                path: href,
            },
            tag: {
                tagName: 'link',
                attributes: {
                    rel: 'apple-touch-startup-image',
                    media: icon.media,
                    // TODO(Bacon): Use sizes to query splash screens better
                    // sizes: `${icon.width}x${icon.height}`,
                    href: path.join(publicPath, href),
                },
            },
        };
    }));
    await Image.Cache.clearUnusedCachesAsync(projectRoot, cacheType);
    return data;
}
exports.generateSplashAsync = generateSplashAsync;
async function generateAppleIconAsync({ projectRoot, publicPath }, icon, { sizes = [180] }) {
    const cacheType = 'apple-touch-icon';
    const data = await Promise.all(sizes.map(async (size) => {
        const rel = 'apple-touch-icon';
        const { source, name } = await Image.generateImageAsync({ projectRoot, cacheType }, Object.assign(Object.assign({}, icon), { width: size, height: size, name: `${rel}-${size}.png` }));
        const href = `pwa/${rel}/${name}`;
        return {
            asset: {
                source,
                path: href,
            },
            tag: {
                tagName: 'link',
                attributes: {
                    rel,
                    sizes: `${size}x${size}`,
                    href: path.join(publicPath, href),
                },
            },
        };
    }));
    // Don't clear the caches if no generation was performed.
    if (!sizes.length) {
        await Image.Cache.clearUnusedCachesAsync(projectRoot, cacheType);
    }
    return data;
}
exports.generateAppleIconAsync = generateAppleIconAsync;
async function generateChromeIconAsync({ projectRoot, publicPath }, icon, { sizes = [144, 192, 512] }) {
    const cacheType = 'chrome-icon';
    const data = await Promise.all(sizes.map(async (size) => {
        const rel = 'chrome-icon';
        const { source, name } = await Image.generateImageAsync({ projectRoot, cacheType }, Object.assign(Object.assign({}, icon), { width: size, height: size, name: `${rel}-${size}.png` }));
        const href = `pwa/${rel}/${name}`;
        return {
            asset: {
                source,
                path: href,
            },
            manifest: {
                src: path.join(publicPath, href),
                sizes: `${size}x${size}`,
                type: 'image/png',
            },
        };
    }));
    // Don't clear the caches if no generation was performed.
    if (!sizes.length) {
        await Image.Cache.clearUnusedCachesAsync(projectRoot, cacheType);
    }
    return data;
}
exports.generateChromeIconAsync = generateChromeIconAsync;
async function generateFaviconAsync({ projectRoot, publicPath }, icon) {
    const cacheType = 'favicon';
    const dimensions = [16, 32, 48];
    const data = await Promise.all(dimensions.map(async (size) => {
        const rel = 'icon';
        const { source, name } = await Image.generateImageAsync({ projectRoot, cacheType }, Object.assign(Object.assign({ backgroundColor: 'transparent' }, icon), { width: size, height: size, name: `favicon-${size}.png` }));
        const href = `${name}`;
        return {
            asset: {
                source,
                path: href,
            },
            tag: {
                tagName: 'link',
                attributes: {
                    rel,
                    type: 'image/png',
                    sizes: `${size}x${size}`,
                    href: path.join(publicPath, href),
                },
            },
        };
    }));
    const faviconUrl = path.join(publicPath, 'favicon.ico');
    const largestImageBuffer = data[data.length - 1].asset.source;
    const faviconBuffer = await Image.generateFaviconAsync(largestImageBuffer, dimensions);
    await Image.Cache.clearUnusedCachesAsync(projectRoot, cacheType);
    return [
        data[0],
        data[1],
        {
            asset: { source: faviconBuffer, path: 'favicon.ico' },
            tag: {
                tagName: 'link',
                attributes: { rel: 'shortcut icon', href: faviconUrl },
            },
        },
    ];
}
exports.generateFaviconAsync = generateFaviconAsync;
async function generateManifestAsync(options, configPath, config) {
    if (configPath) {
        config_1.setCustomConfigPath(options.projectRoot, configPath);
    }
    const manifest = generateManifestJson(options, config);
    return [
        {
            // TODO: Bacon: Make the types more flexible
            asset: { source: JSON.stringify(manifest, null, 2), path: 'manifest.json' },
            tag: {
                tagName: 'link',
                attributes: { rel: 'manifest', href: path.join(options.publicPath, 'manifest.json') },
            },
        },
    ];
}
exports.generateManifestAsync = generateManifestAsync;
function generateManifestJson({ projectRoot }, config) {
    if (!config) {
        if (!projectRoot)
            throw new Error('You must either define projectRoot or config');
        config = Manifest_1.getConfigForPWA(projectRoot);
    }
    return Manifest_1.createPWAManifestFromWebConfig(config.web);
}
exports.generateManifestJson = generateManifestJson;
var Manifest_2 = require("./Manifest");
exports.getSafariStartupImageConfig = Manifest_2.getSafariStartupImageConfig;
exports.getSafariIconConfig = Manifest_2.getSafariIconConfig;
exports.getFaviconIconConfig = Manifest_2.getFaviconIconConfig;
exports.getChromeIconConfig = Manifest_2.getChromeIconConfig;
//# sourceMappingURL=index.js.map